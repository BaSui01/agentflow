# Agent 开发教程

AgentFlow 提供完整的 Agent 开发框架，支持状态管理、多层记忆、技能系统、MCP 集成、安全护栏、高级推理模式、Human-in-the-Loop、异步执行、语音交互、沙箱执行等企业级特性。

## 基础 Agent 创建

### 使用 Builder 模式

```go
import (
    "github.com/BaSui01/agentflow/agent"
    "github.com/BaSui01/agentflow/providers/openai"
)

// 创建 Provider
provider := openai.NewOpenAIProvider(cfg, logger)

// 使用 Builder 构建 Agent
myAgent, err := agent.NewAgentBuilder(agent.Config{
    ID:           "assistant-001",
    Name:         "智能助手",
    Type:         agent.TypeAssistant,
    Model:        "gpt-4o",
    MaxTokens:    4096,
    Temperature:  0.7,
    PromptBundle: agent.PromptBundle{
        Version: "1.0.0",
        System: agent.SystemPrompt{
            Identity: "你是一个专业的技术助手",
            Policies: []string{"保持专业", "提供准确信息"},
            OutputRules: []string{"使用清晰的语言"},
            Prohibits: []string{"不要泄露敏感信息"},
        },
        Constraints: []string{"回答要简洁"},
    },
    Tools: []string{"search", "calculator", "code_executor"},
    EnableReflection:     true,
    EnableToolSelection:  true,
    EnablePromptEnhancer: true,
}).
    WithProvider(provider).
    WithLogger(logger).
    WithReflection(nil).
    WithToolSelection(nil).
    Build()

if err != nil {
    log.Fatal(err)
}
```

### Agent 类型

```go
const (
    TypeGeneric    AgentType = "generic"    // 通用 Agent
    TypeAssistant  AgentType = "assistant"  // 助手
    TypeAnalyzer   AgentType = "analyzer"   // 分析
    TypeTranslator AgentType = "translator" // 翻译
    TypeSummarizer AgentType = "summarizer" // 摘要
    TypeReviewer   AgentType = "reviewer"   // 审查
)
```

### Agent 生命周期

```go
// 创建生命周期管理器
lifecycle := agent.NewLifecycleManager(myAgent, logger)

// 启动（包含初始化和健康检查）
if err := lifecycle.Start(ctx); err != nil {
    log.Fatal(err)
}

// 检查运行状态
if lifecycle.IsRunning() {
    // 获取健康状态
    health := lifecycle.GetHealthStatus()
    fmt.Printf("健康: %v, 状态: %s\n", health.Healthy, health.State)
}

// 执行任务
response, err := myAgent.Execute(ctx, &agent.Input{
    TraceID: "trace-001",
    Content: "帮我分析这段代码",
    Variables: map[string]string{
        "language": "Go",
    },
})

// 重启
lifecycle.Restart(ctx)

// 停止
lifecycle.Stop(ctx)
```

### 状态机

Agent 有严格的状态转换：

```
Init → Ready → Running → Ready → Stopped
         ↑       ↓
         └───────┘
```

```go
// 状态定义
const (
    StateInit     State = "init"
    StateReady    State = "ready"
    StateRunning  State = "running"
    StateStopped  State = "stopped"
    StateError    State = "error"
)

// 检查状态
state := myAgent.State()
if state == agent.StateReady {
    // 可以执行任务
}

// 状态转换（带校验）
if err := myAgent.Transition(ctx, agent.StateRunning); err != nil {
    log.Printf("状态转换失败: %v", err)
}
```

## 模块化提示词系统 (PromptBundle)

### 提示词包结构

```go
type PromptBundle struct {
    Version     string            `json:"version"`
    System      SystemPrompt      `json:"system"`
    Tools       []llm.ToolSchema  `json:"tools,omitempty"`
    Examples    []Example         `json:"examples,omitempty"`    // Few-shot 示例
    Memory      MemoryConfig      `json:"memory,omitempty"`
    Plan        *PlanConfig       `json:"plan,omitempty"`
    Reflection  *ReflectionConfig `json:"reflection,omitempty"`
    Constraints []string          `json:"constraints,omitempty"`
}

type SystemPrompt struct {
    Role        string   `json:"role,omitempty"`        // 角色定义
    Identity    string   `json:"identity,omitempty"`    // 身份描述
    Policies    []string `json:"policies,omitempty"`    // 行为政策
    OutputRules []string `json:"output_rules,omitempty"` // 输出规则
    Prohibits   []string `json:"prohibits,omitempty"`   // 禁止行为
}
```

### 模板变量替换

```go
bundle := agent.PromptBundle{
    Version: "1.0.0",
    System: agent.SystemPrompt{
        Identity: "你是 {{company}} 的 {{role}}",
        Policies: []string{
            "使用 {{language}} 语言回答",
            "遵循 {{style}} 风格",
        },
    },
}

// 提取所有变量
vars := bundle.ExtractVariables() // ["company", "role", "language", "style"]

// 渲染系统提示词
prompt := bundle.RenderSystemPromptWithVars(map[string]string{
    "company":  "AgentFlow",
    "role":     "技术助手",
    "language": "中文",
    "style":    "专业简洁",
})

// 渲染 Few-shot 示例为消息
messages := bundle.RenderExamplesAsMessagesWithVars(vars)
```

### 提示词增强器

```go
import "github.com/BaSui01/agentflow/agent"

// 创建提示词增强器
enhancer := agent.NewPromptEnhancer(agent.PromptEngineeringConfig{
    UseChainOfThought:   true,  // 启用思维链
    UseSelfConsistency:  false, // 自一致性
    UseStructuredOutput: true,  // 结构化输出
    UseFewShot:          true,  // Few-shot 学习
    MaxExamples:         3,     // 最多 3 个示例
    UseDelimiters:       true,  // 使用分隔符
})

// 增强提示词包
enhancedBundle := enhancer.EnhancePromptBundle(bundle)

// 增强用户提示词
enhancedPrompt := enhancer.EnhanceUserPrompt(
    "分析这段代码",
    `{"analysis": "...", "suggestions": [...]}`, // 输出格式
)
```

### 提示词模板库

```go
// 创建模板库
library := agent.NewPromptTemplateLibrary()

// 内置模板：analysis, summary, code_generation, qa, creative
template, _ := library.GetTemplate("code_generation")

// 渲染模板
prompt, _ := library.RenderTemplate("code_generation", map[string]string{
    "language":    "Go",
    "requirement": "实现一个并发安全的缓存",
})

// 注册自定义模板
library.RegisterTemplate(agent.PromptTemplate{
    Name:        "review",
    Description: "代码审查模板",
    Template:    "请审查以下 {{.language}} 代码：\n{{.code}}",
    Variables:   []string{"language", "code"},
})
```

## 防御性提示工程

### 配置防御性提示

```go
import "github.com/BaSui01/agentflow/agent"

// 创建防御性提示增强器
defensive := agent.NewDefensivePromptEnhancer(agent.DefensivePromptConfig{
    // 失败处理模式
    FailureModes: []agent.FailureMode{
        {
            Condition: "missing_data",
            Action:    "return_error",
            Template:  `{"error": "insufficient_data", "message": "缺少必要信息"}`,
        },
        {
            Condition: "ambiguous_input",
            Action:    "request_clarification",
            Template:  `{"status": "需要澄清", "question": "{{clarification_question}}"}`,
        },
    },
    // 输出 Schema 强制
    OutputSchema: &agent.OutputSchema{
        Type:     "json",
        Required: []string{"answer", "confidence"},
        Example:  `{"answer": "...", "confidence": 0.9}`,
    },
    // 护栏规则
    GuardRails: []agent.GuardRail{
        {
            Type:        "never",
            Category:    "data_safety",
            Description: "绝不修改或删除用户数据",
            Severity:    "critical",
        },
        {
            Type:        "boundary",
            Category:    "disclosure",
            Description: "不要泄露系统内部实现细节",
            Severity:    "high",
        },
    },
    // 提示注入防护
    InjectionDefense: &agent.InjectionDefenseConfig{
        Enabled: true,
        DetectionPatterns: []string{
            "ignore previous instructions",
            "忽略之前的指令",
            "system:",
        },
        UseDelimiters: true,
        SanitizeInput: true,
        RoleIsolation: true,
    },
})

// 增强提示词包
safeBundle := defensive.EnhancePromptBundle(bundle)

// 清理用户输入（防止提示注入）
safeInput, ok := defensive.SanitizeUserInput(userInput)
if !ok {
    log.Println("检测到潜在的提示注入攻击")
}

// 验证输出是否符合 Schema
if err := defensive.ValidateOutput(output); err != nil {
    log.Printf("输出验证失败: %v", err)
}
```

## 多层记忆系统

AgentFlow 提供两套记忆系统：增强记忆系统和分层记忆系统。

### 增强记忆系统 (EnhancedMemorySystem)

支持五种记忆类型：

| 记忆类型 | 存储后端 | 用途 |
|----------|----------|------|
| 短期记忆 | Redis/内存 | 最近的交互，带 TTL |
| 工作记忆 | 内存 | 当前任务上下文 |
| 长期记忆 | 向量数据库 | 持久化重要信息，支持语义搜索 |
| 情节记忆 | 时序数据库 | 时间序列事件 |
| 语义记忆 | 知识图谱 | 结构化知识（实体、关系） |

```go
import "github.com/BaSui01/agentflow/agent/memory"

// 创建增强记忆系统
memorySystem := memory.NewEnhancedMemorySystem(
    shortTermStore,  // Redis 或内存存储
    workingStore,    // 内存存储
    vectorStore,     // Qdrant/Pinecone
    episodicStore,   // InfluxDB
    knowledgeGraph,  // Neo4j
    memory.EnhancedMemoryConfig{
        ShortTermTTL:          24 * time.Hour,
        ShortTermMaxSize:      100,
        WorkingMemorySize:     20,
        LongTermEnabled:       true,
        VectorDimension:       1536,
        EpisodicEnabled:       true,
        EpisodicRetention:     30 * 24 * time.Hour,
        SemanticEnabled:       true,
        ConsolidationEnabled:  true,
        ConsolidationInterval: 1 * time.Hour,
    },
    logger,
)

// 保存短期记忆
memorySystem.SaveShortTerm(ctx, agentID, "用户喜欢简洁回答", metadata)

// 保存长期记忆（向量化）
memorySystem.SaveLongTerm(ctx, agentID, content, embedding, metadata)

// 语义搜索长期记忆
results, _ := memorySystem.SearchLongTerm(ctx, agentID, queryVector, topK)

// 记录情节
memorySystem.RecordEpisode(ctx, &memory.EpisodicEvent{
    AgentID:   agentID,
    Type:      "task_completed",
    Content:   "完成代码审查任务",
    Timestamp: time.Now(),
})

// 添加知识（实体和关系）
memorySystem.AddKnowledge(ctx, &memory.Entity{
    ID:   "user_123",
    Type: "user",
    Name: "张三",
    Properties: map[string]interface{}{
        "preference": "简洁",
    },
})

// 启动记忆整合（后台自动将短期记忆转移到长期记忆）
memorySystem.StartConsolidation(ctx)
```

### 分层记忆系统 (LayeredMemory)

更轻量的四层记忆：

```go
layeredMemory := memory.NewLayeredMemory(memory.LayeredMemoryConfig{
    EpisodicMaxSize: 1000,
    WorkingCapacity: 50,
    WorkingTTL:      30 * time.Minute,
    Embedder:        embedder,
    ProceduralConfig: memory.ProceduralConfig{
        MaxProcedures: 100,
    },
}, logger)

// 情节记忆：存储事件
layeredMemory.Episodic.Store(&memory.Episode{
    Context:    "用户询问 Go 并发",
    Action:     "解释 goroutine 和 channel",
    Result:     "用户理解了",
    Importance: 0.8,
})

// 语义记忆：存储事实
layeredMemory.Semantic.StoreFact(ctx, &memory.Fact{
    Subject:    "Go",
    Predicate:  "支持",
    Object:     "并发编程",
    Confidence: 1.0,
})

// 工作记忆：当前上下文
layeredMemory.Working.Set("current_topic", "Go 并发", 10)

// 程序记忆：存储操作步骤
layeredMemory.Procedural.Store(&memory.Procedure{
    Name:        "代码审查",
    Description: "审查 Go 代码的标准流程",
    Steps:       []string{"检查格式", "检查错误处理", "检查并发安全"},
    Triggers:    []string{"review", "审查"},
})
```

## 技能系统

基于 Anthropic Agent Skills 标准设计的技能系统。

### 定义技能

```go
import "github.com/BaSui01/agentflow/agent/skills"

// 使用 Builder 创建技能
skill, _ := skills.NewSkillBuilder("code_review", "代码审查").
    WithDescription("审查代码质量、安全性和最佳实践").
    WithCategory("development").
    WithTags("code", "review", "quality").
    WithInstructions(`
        你是一个代码审查专家。审查代码时请关注：
        1. 代码风格和可读性
        2. 潜在的 bug 和安全问题
        3. 性能优化建议
        4. 最佳实践遵循情况
    `).
    WithTools("read_file", "search_code", "run_tests").
    WithExample(
        "审查这个函数的代码质量",
        "发现 3 个问题：1. 缺少错误处理...",
        "展示了完整的代码审查流程",
    ).
    WithPriority(10).
    Build()
```

### 技能管理器

```go
// 创建技能管理器
manager := skills.NewSkillManager(skills.SkillManagerConfig{
    AutoLoad:        true,
    MaxLoadedSkills: 10,
    MinMatchScore:   0.3,
    EnableCaching:   true,
}, logger)

// 扫描技能目录
manager.ScanDirectory("./skills")

// 注册技能
manager.RegisterSkill(skill)

// 根据任务发现技能
matchedSkills, _ := manager.DiscoverSkills(ctx, "帮我审查这段 Go 代码")

// 加载技能
loadedSkill, _ := manager.LoadSkill(ctx, "code_review")

// 渲染技能指令
instructions := loadedSkill.RenderInstructions(map[string]string{
    "language": "Go",
    "focus":    "并发安全",
})
```

### 技能文件结构

```
skills/
├── code_review/
│   ├── SKILL.json      # 技能清单
│   ├── prompts.txt     # 提示词模板
│   └── examples.json   # 示例数据
```

## MCP 集成

Model Context Protocol (MCP) 客户端集成：

```go
import "github.com/BaSui01/agentflow/agent/mcp"

// 创建 MCP 客户端
client := mcp.NewMCPClient(reader, writer, logger)

// 连接服务器
client.Connect(ctx, "mcp://localhost:8080")

// 列出可用工具
tools, _ := client.ListTools(ctx)

// 调用工具
result, _ := client.CallTool(ctx, "search", map[string]interface{}{
    "query": "Go 并发最佳实践",
})

// 列出资源
resources, _ := client.ListResources(ctx)

// 读取资源
resource, _ := client.ReadResource(ctx, "file:///path/to/file")

// 订阅资源更新
updates, _ := client.SubscribeResource(ctx, "file:///config.json")
go func() {
    for update := range updates {
        fmt.Printf("资源更新: %v\n", update)
    }
}()

// 获取提示词模板
prompt, _ := client.GetPrompt(ctx, "code_review", map[string]string{
    "language": "Go",
})

// 批量调用工具
results, _ := client.BatchCallTools(ctx, []mcp.ToolCall{
    {Name: "search", Arguments: json.RawMessage(`{"query": "test"}`)},
    {Name: "read_file", Arguments: json.RawMessage(`{"path": "main.go"}`)},
})
```

## 安全护栏

### 验证器

```go
import "github.com/BaSui01/agentflow/agent/guardrails"

// 创建护栏配置
config := &guardrails.GuardrailsConfig{
    MaxInputLength:      10000,
    BlockedKeywords:     []string{"password", "secret"},
    PIIDetectionEnabled: true,
    InjectionDetection:  true,
    OnInputFailure:      guardrails.FailureActionReject,
    OnOutputFailure:     guardrails.FailureActionWarn,
}

// 创建验证器链
chain := guardrails.NewValidatorChain(logger)

// 添加内置验证器
chain.Add(guardrails.NewLengthValidator(10000))
chain.Add(guardrails.NewKeywordValidator([]string{"password"}))
chain.Add(guardrails.NewPIIDetector(guardrails.PIIConfig{
    DetectEmail:   true,
    DetectPhone:   true,
    DetectSSN:     true,
    DetectCreditCard: true,
}))
chain.Add(guardrails.NewInjectionDetector(guardrails.InjectionConfig{
    Patterns: []string{
        `ignore previous instructions`,
        `system prompt`,
        `<script>`,
    },
    Threshold: 0.7,
}))

// 验证输入
result, _ := chain.Validate(ctx, userInput)
if !result.Valid {
    for _, err := range result.Errors {
        log.Printf("验证失败: [%s] %s", err.Code, err.Message)
    }
}
```

### 输出过滤器

```go
// 创建输出过滤器
filter := guardrails.NewOutputFilter(guardrails.OutputConfig{
    MaxLength:       5000,
    RemovePII:       true,
    SanitizeHTML:    true,
    BlockedPatterns: []string{`<script>`, `javascript:`},
})

// 过滤输出
safeOutput, _ := filter.Filter(ctx, agentOutput)
```

### 自定义验证器

```go
type CustomValidator struct {
    name     string
    priority int
}

func (v *CustomValidator) Validate(ctx context.Context, content string) (*guardrails.ValidationResult, error) {
    result := guardrails.NewValidationResult()
    
    // 自定义验证逻辑
    if strings.Contains(content, "危险内容") {
        result.AddError(guardrails.ValidationError{
            Code:     "CUSTOM_ERROR",
            Message:  "检测到危险内容",
            Severity: guardrails.SeverityHigh,
        })
    }
    
    return result, nil
}

func (v *CustomValidator) Name() string     { return v.name }
func (v *CustomValidator) Priority() int    { return v.priority }

// 注册自定义验证器
registry := guardrails.NewValidatorRegistry()
registry.Register(&CustomValidator{name: "custom", priority: 100})
```

## 高级推理模式

AgentFlow 提供多种高级推理模式，适用于不同复杂度的任务。

### Tree of Thought (ToT)

探索多条推理路径，选择最优解：

```go
import "github.com/BaSui01/agentflow/agent/reasoning"

tot := reasoning.NewTreeOfThought(provider, toolExecutor, reasoning.TreeOfThoughtConfig{
    BranchingFactor: 3,      // 每步生成 3 个思路
    MaxDepth:        5,      // 最大深度 5 层
    BeamWidth:       2,      // 保留最优的 2 条路径
    EvaluationMode:  "self", // LLM 自评估
    PruneThreshold:  0.3,    // 低于 0.3 分的路径被剪枝
    Timeout:         120 * time.Second,
    ParallelEval:    true,   // 并行评估
}, logger)

result, _ := tot.Execute(ctx, "设计一个高并发的消息队列系统")

fmt.Printf("最终答案: %s\n", result.FinalAnswer)
fmt.Printf("置信度: %.2f\n", result.Confidence)
fmt.Printf("推理步骤: %d\n", len(result.Steps))
fmt.Printf("总 Token: %d\n", result.TotalTokens)
```

### ReWOO (Reasoning Without Observation)

先规划后执行，适合工具密集型任务：

```go
rewoo := reasoning.NewReWOO(provider, toolExecutor, toolSchemas, reasoning.ReWOOConfig{
    MaxPlanSteps:    10,              // 最大计划步骤
    Timeout:         120 * time.Second,
    ParallelWorkers: 5,               // 并行执行工作线程
}, logger)

// 三阶段执行：Planner → Worker → Solver
result, _ := rewoo.Execute(ctx, "收集并分析最近一周的销售数据")

// 结果包含计划步骤和观察结果
fmt.Printf("计划步骤: %d\n", result.Metadata["plan_steps"])
fmt.Printf("观察结果: %d\n", result.Metadata["observations"])
```

### Reflexion (自我反思改进)

通过多次尝试和反思不断改进：

```go
reflexion := reasoning.NewReflexionExecutor(provider, toolExecutor, toolSchemas, reasoning.ReflexionConfig{
    MaxTrials:        5,    // 最多尝试 5 次
    SuccessThreshold: 0.8,  // 成功阈值
    Timeout:          300 * time.Second,
    EnableMemory:     true, // 启用经验记忆
}, logger)

result, _ := reflexion.Execute(ctx, "编写一个高效的排序算法")

// 每次尝试都会生成反思
for _, step := range result.Steps {
    if step.Type == "reflection" {
        fmt.Printf("反思: %s\n", step.Content)
    }
}
```

### Plan-and-Execute (计划执行)

支持自适应重规划：

```go
planExec := reasoning.NewPlanAndExecute(provider, toolExecutor, toolSchemas, reasoning.PlanExecuteConfig{
    MaxPlanSteps:      15,  // 最大计划步骤
    MaxReplanAttempts: 3,   // 最多重规划 3 次
    Timeout:           180 * time.Second,
    AdaptivePlanning:  true, // 允许执行中修改计划
}, logger)

result, _ := planExec.Execute(ctx, "部署一个微服务应用")

fmt.Printf("完成步骤: %d/%d\n", 
    result.Metadata["completed_steps"], 
    result.Metadata["total_steps"])
fmt.Printf("重规划次数: %d\n", result.Metadata["replan_attempts"])
```

### Dynamic Planner (动态规划器)

支持回溯和备选方案：

```go
planner := reasoning.NewDynamicPlanner(provider, toolExecutor, toolSchemas, reasoning.DynamicPlannerConfig{
    MaxBacktracks:       5,    // 最大回溯次数
    MaxPlanDepth:        20,   // 最大计划深度
    ConfidenceThreshold: 0.4,  // 置信度阈值
    Timeout:             180 * time.Second,
    EnableParallel:      true, // 并行路径探索
    MaxParallelPaths:    3,    // 最大并行路径数
}, logger)

result, _ := planner.Execute(ctx, "解决复杂的优化问题")

fmt.Printf("回溯次数: %d\n", result.Metadata["backtracks"])
fmt.Printf("总节点数: %d\n", result.Metadata["total_nodes"])
```

### 反思机制

Agent 自我评估和改进：

```go
agent.NewAgentBuilder(cfg).
    WithReflection(&agent.ReflectionExecutorConfig{
        MaxIterations: 3,    // 最多反思 3 次
        Threshold:     0.8,  // 质量阈值
        Criteria: []string{
            "准确性",
            "完整性",
            "清晰度",
        },
    }).
    Build()
```

### 动态工具选择

根据任务自动选择合适的工具：

```go
agent.NewAgentBuilder(cfg).
    WithToolSelection(&agent.ToolSelectionConfig{
        MaxTools:  5,           // 最多选择 5 个工具
        Strategy:  "relevance", // 按相关性选择
        Threshold: 0.5,         // 相关性阈值
    }).
    Build()
```

## Human-in-the-Loop (人机协作)

### 审批管理器

```go
import "github.com/BaSui01/agentflow/agent"

// 创建审批存储
store := agent.NewInMemoryApprovalStore()

// 创建 HITL 管理器
hitlManager := agent.NewHumanInLoopManager(store, eventBus, logger)

// 请求人工审批
response, err := hitlManager.RequestApproval(ctx, 
    agentID,
    agent.ApprovalTypeToolCall,  // 审批类型：工具调用
    "Agent 请求执行删除操作",
    5 * time.Minute,             // 超时时间
)

if err != nil {
    log.Printf("审批超时或失败: %v", err)
}

if response.Approved {
    // 执行操作
} else {
    log.Printf("操作被拒绝: %s", response.Reason)
}
```

### 审批类型

```go
const (
    ApprovalTypeToolCall    ApprovalType = "tool_call"     // 工具调用审批
    ApprovalTypeOutput      ApprovalType = "output"        // 输出审批
    ApprovalTypeStateChange ApprovalType = "state_change"  // 状态变更审批
    ApprovalTypeDataAccess  ApprovalType = "data_access"   // 数据访问审批
    ApprovalTypeCustom      ApprovalType = "custom"        // 自定义审批
)
```

### 审批策略

```go
// 创建审批策略
policy := &agent.DefaultApprovalPolicy{
    RequireApprovalTools:  []string{"delete_file", "send_email", "execute_sql"},
    RequireApprovalStates: []agent.State{agent.StateStopped},
    AlwaysRequireApproval: false,
}

// 检查是否需要审批
action := agent.Action{
    Type:    "tool_call",
    Content: "delete_file",
    Metadata: map[string]interface{}{
        "tool_name": "delete_file",
    },
}

if policy.RequiresApproval(ctx, agentID, action) {
    // 请求审批
}
```

### 工作流中断管理

```go
import "github.com/BaSui01/agentflow/agent/hitl"

// 创建中断管理器
interruptManager := hitl.NewInterruptManager(store, logger)

// 注册中断处理器
interruptManager.RegisterHandler(hitl.InterruptTypeApproval, func(ctx context.Context, interrupt *hitl.Interrupt) error {
    // 发送通知给审批人
    return notifyApprover(interrupt)
})

// 创建中断点
response, err := interruptManager.CreateInterrupt(ctx, hitl.InterruptOptions{
    WorkflowID:  "workflow-001",
    NodeID:      "step-3",
    Type:        hitl.InterruptTypeApproval,
    Title:       "需要审批",
    Description: "Agent 请求执行敏感操作",
    Options: []hitl.Option{
        {ID: "approve", Label: "批准", IsDefault: true},
        {ID: "reject", Label: "拒绝"},
    },
    Timeout: 10 * time.Minute,
})

// 解决中断
interruptManager.ResolveInterrupt(ctx, interruptID, &hitl.Response{
    OptionID: "approve",
    Approved: true,
    Comment:  "已审核，可以执行",
})
```

## 异步执行与 Subagent

### 异步执行器

```go
import "github.com/BaSui01/agentflow/agent"

// 创建异步执行器
asyncExecutor := agent.NewAsyncExecutor(myAgent, logger)

// 异步执行任务
execution, _ := asyncExecutor.ExecuteAsync(ctx, &agent.Input{
    TraceID: "async-001",
    Content: "执行长时间任务",
})

// 检查执行状态
fmt.Printf("执行 ID: %s, 状态: %s\n", execution.ID, execution.Status)

// 等待完成
output, err := execution.Wait(ctx)
if err != nil {
    log.Printf("执行失败: %v", err)
}
```

### Subagent 并行执行

```go
// 创建多个 Subagent
subagents := []agent.Agent{
    createAnalyzerAgent(),
    createSummarizerAgent(),
    createReviewerAgent(),
}

// 并行执行
output, err := asyncExecutor.ExecuteWithSubagents(ctx, input, subagents)

// 结果自动合并
fmt.Printf("Subagent 数量: %d\n", output.Metadata["subagent_count"])
```

### 实时协调器

```go
// 创建 Subagent 管理器
manager := agent.NewSubagentManager(logger)

// 创建实时协调器
coordinator := agent.NewRealtimeCoordinator(manager, eventBus, logger)

// 协调多个 Subagent
output, err := coordinator.CoordinateSubagents(ctx, subagents, input)

// 监听完成事件
eventBus.Subscribe(agent.EventSubagentCompleted, func(event agent.Event) {
    e := event.(*agent.SubagentCompletedEvent)
    fmt.Printf("Subagent %s 完成\n", e.AgentID)
})
```

## 语音交互

### 实时语音 Agent

```go
import "github.com/BaSui01/agentflow/agent/voice"

// 创建语音 Agent
voiceAgent := voice.NewVoiceAgent(voice.VoiceConfig{
    STTProvider:      "deepgram",     // 语音转文字
    TTSProvider:      "elevenlabs",   // 文字转语音
    SampleRate:       16000,
    MaxLatencyMS:     300,            // 目标延迟
    VADEnabled:       true,           // 语音活动检测
    InterruptEnabled: true,           // 允许打断
    BufferDuration:   100 * time.Millisecond,
}, sttProvider, ttsProvider, llmHandler, logger)

// 启动语音会话
session, _ := voiceAgent.Start(ctx)

// 发送音频数据
session.SendAudio(voice.AudioChunk{
    Data:       audioData,
    SampleRate: 16000,
    Channels:   1,
})

// 接收合成语音
for speech := range session.ReceiveSpeech() {
    playAudio(speech.Audio)
}

// 打断当前语音
session.Interrupt()

// 关闭会话
session.Close()
```

### 原生多模态音频推理

```go
// 创建原生音频推理器（GPT-4o 风格，目标 232ms 延迟）
reasoner := voice.NewNativeAudioReasoner(audioProvider, voice.NativeAudioConfig{
    TargetLatencyMS: 232,
    SampleRate:      24000,
    ChunkSizeMS:     20,
    BufferSize:      4096,
    EnableVAD:       true,
    Timeout:         30 * time.Second,
}, logger)

// 处理多模态输入
output, _ := reasoner.Process(ctx, voice.MultimodalInput{
    Audio: audioFrames,
    Text:  "补充文本",
})

fmt.Printf("延迟: %dms, 目标命中率: %.2f%%\n", 
    output.LatencyMS, 
    reasoner.GetMetrics().TargetHitRate * 100)

// 流式处理（最低延迟）
outputChan, _ := reasoner.StreamProcess(ctx, inputChan)
for frame := range outputChan {
    playFrame(frame)
}
```

## 沙箱代码执行

### 安全沙箱

```go
import "github.com/BaSui01/agentflow/agent/sandbox"

// 创建 Docker 后端
backend := sandbox.NewDockerBackend(logger)

// 创建沙箱执行器
executor := sandbox.NewSandboxExecutor(sandbox.SandboxConfig{
    Mode:             sandbox.ModeDocker,
    Timeout:          30 * time.Second,
    MaxMemoryMB:      512,
    MaxCPUPercent:    50,
    NetworkEnabled:   false,           // 禁用网络
    MaxOutputBytes:   1024 * 1024,     // 1MB 输出限制
    AllowedLanguages: []sandbox.Language{
        sandbox.LangPython,
        sandbox.LangJavaScript,
    },
}, backend, logger)

// 执行代码
result, _ := executor.Execute(ctx, &sandbox.ExecutionRequest{
    ID:       "exec-001",
    Language: sandbox.LangPython,
    Code:     "print('Hello, World!')",
    Timeout:  10 * time.Second,
})

fmt.Printf("成功: %v, 输出: %s\n", result.Success, result.Stdout)
```

### 代码验证器

```go
// 创建代码验证器
validator := sandbox.NewCodeValidator()

// 验证代码安全性
warnings := validator.Validate(sandbox.LangPython, code)
if len(warnings) > 0 {
    for _, w := range warnings {
        log.Printf("警告: %s", w)
    }
}
```

### 沙箱工具

```go
// 创建沙箱工具（供 Agent 使用）
sandboxTool := sandbox.NewSandboxTool(executor, logger)

// 作为工具调用
result, _ := sandboxTool.Execute(ctx, json.RawMessage(`{
    "language": "python",
    "code": "result = sum(range(100))\nprint(result)"
}`))
```

## 事件系统

```go
// 创建事件总线
bus := agent.NewEventBus()

// 事件类型
const (
    EventStateChange       EventType = "state_change"
    EventToolCall          EventType = "tool_call"
    EventFeedback          EventType = "feedback"
    EventApprovalRequested EventType = "approval_requested"
    EventApprovalResponded EventType = "approval_responded"
    EventSubagentCompleted EventType = "subagent_completed"
)

// 订阅状态变更事件
bus.Subscribe(agent.EventStateChange, func(event agent.Event) {
    e := event.(*agent.StateChangeEvent)
    log.Printf("Agent %s: %s → %s", e.AgentID_, e.FromState, e.ToState)
})

// 订阅工具调用事件
bus.Subscribe(agent.EventToolCall, func(event agent.Event) {
    e := event.(*agent.ToolCallEvent)
    log.Printf("工具调用: %s, 阶段: %s", e.ToolName, e.Stage)
})

// 订阅审批事件
bus.Subscribe(agent.EventApprovalRequested, func(event agent.Event) {
    e := event.(*agent.ApprovalRequestedEvent)
    log.Printf("审批请求: %s, 类型: %s", e.RequestID, e.ApprovalType)
})

// 取消订阅
subscriptionID := bus.Subscribe(agent.EventFeedback, handler)
bus.Unsubscribe(subscriptionID)

// 使用事件总线
agent.NewAgentBuilder(cfg).
    WithEventBus(bus).
    Build()
```

## 层级 Agent (Hierarchical Agent)

支持 Supervisor-Worker 模式的层级 Agent 系统。

### 创建层级 Agent

```go
import "github.com/BaSui01/agentflow/agent/hierarchical"

// 创建层级 Agent
hierarchicalAgent := hierarchical.NewHierarchicalAgent(hierarchical.HierarchicalConfig{
    MaxWorkers:       10,
    TaskTimeout:      5 * time.Minute,
    RetryAttempts:    3,
    LoadBalancing:    hierarchical.LoadBalanceRoundRobin,
    EnableMonitoring: true,
}, provider, logger)

// 注册 Worker Agent
hierarchicalAgent.RegisterWorker("analyzer", analyzerAgent)
hierarchicalAgent.RegisterWorker("summarizer", summarizerAgent)
hierarchicalAgent.RegisterWorker("reviewer", reviewerAgent)

// 执行任务（自动分配给合适的 Worker）
result, _ := hierarchicalAgent.Execute(ctx, &hierarchical.Task{
    ID:          "task-001",
    Type:        "analysis",
    Description: "分析代码质量",
    Priority:    hierarchical.PriorityHigh,
    Data:        taskData,
})
```

### 任务协调器

```go
// 创建任务协调器
coordinator := hierarchical.NewTaskCoordinator(hierarchical.CoordinatorConfig{
    MaxConcurrent:    5,
    QueueSize:        100,
    SchedulingPolicy: hierarchical.SchedulePriority,
    EnablePreemption: true,
}, logger)

// 提交任务
taskID, _ := coordinator.Submit(ctx, &hierarchical.Task{
    Type:     "review",
    Priority: hierarchical.PriorityHigh,
    Deadline: time.Now().Add(10 * time.Minute),
})

// 等待任务完成
result, _ := coordinator.Wait(ctx, taskID)

// 取消任务
coordinator.Cancel(ctx, taskID)

// 获取队列状态
status := coordinator.GetQueueStatus()
fmt.Printf("待处理: %d, 运行中: %d, 已完成: %d\n", 
    status.Pending, status.Running, status.Completed)
```

### 负载均衡策略

```go
const (
    LoadBalanceRoundRobin   LoadBalanceStrategy = "round_robin"   // 轮询
    LoadBalanceLeastBusy    LoadBalanceStrategy = "least_busy"    // 最空闲
    LoadBalanceWeighted     LoadBalanceStrategy = "weighted"      // 加权
    LoadBalanceCapability   LoadBalanceStrategy = "capability"    // 按能力匹配
)
```

## 多 Agent 协作

支持多种协作模式的多 Agent 系统。

### 协作模式

```go
import "github.com/BaSui01/agentflow/agent/collaboration"

// 创建多 Agent 协调器
multiAgent := collaboration.NewMultiAgentCoordinator(collaboration.MultiAgentConfig{
    MaxAgents:        10,
    CommunicationTTL: 5 * time.Minute,
    EnableLogging:    true,
}, logger)

// 注册 Agent
multiAgent.RegisterAgent("analyst", analystAgent)
multiAgent.RegisterAgent("critic", criticAgent)
multiAgent.RegisterAgent("synthesizer", synthesizerAgent)
```

### 辩论模式 (Debate)

多个 Agent 辩论得出最佳答案：

```go
result, _ := multiAgent.Debate(ctx, collaboration.DebateConfig{
    Topic:      "最佳的微服务架构方案",
    Rounds:     3,                    // 辩论轮数
    Moderator:  "synthesizer",        // 主持人
    Debaters:   []string{"analyst", "critic"},
    VotingMode: collaboration.VoteMajority,
})

fmt.Printf("最终结论: %s\n", result.Conclusion)
fmt.Printf("支持率: %.2f%%\n", result.Confidence * 100)
```

### 共识模式 (Consensus)

所有 Agent 达成共识：

```go
result, _ := multiAgent.Consensus(ctx, collaboration.ConsensusConfig{
    Question:   "系统应该使用什么数据库？",
    Agents:     []string{"analyst", "critic", "synthesizer"},
    Threshold:  0.8,                  // 共识阈值
    MaxRounds:  5,                    // 最大轮数
    Timeout:    10 * time.Minute,
})

if result.ConsensusReached {
    fmt.Printf("达成共识: %s\n", result.Decision)
}
```

### 流水线模式 (Pipeline)

Agent 按顺序处理：

```go
result, _ := multiAgent.Pipeline(ctx, collaboration.PipelineConfig{
    Input: "原始需求文档",
    Stages: []collaboration.Stage{
        {Agent: "analyst", Task: "分析需求"},
        {Agent: "designer", Task: "设计方案"},
        {Agent: "reviewer", Task: "审查方案"},
    },
    PassThrough: true,  // 传递中间结果
})
```

### 广播模式 (Broadcast)

同时向所有 Agent 发送任务：

```go
results, _ := multiAgent.Broadcast(ctx, collaboration.BroadcastConfig{
    Message:    "评估这个技术方案",
    Agents:     []string{"analyst", "critic", "security_expert"},
    Timeout:    5 * time.Minute,
    WaitAll:    true,  // 等待所有响应
})

for agentID, result := range results {
    fmt.Printf("%s 的评估: %s\n", agentID, result.Content)
}
```

### 网络模式 (Network)

Agent 之间自由通信：

```go
network := multiAgent.CreateNetwork(ctx, collaboration.NetworkConfig{
    Agents:      []string{"a", "b", "c", "d"},
    Topology:    collaboration.TopologyMesh,  // 全连接
    MessageTTL:  1 * time.Minute,
})

// Agent 之间发送消息
network.Send("a", "b", "需要你的帮助分析这个问题")

// 监听消息
network.OnMessage("b", func(from string, msg string) {
    fmt.Printf("收到来自 %s 的消息: %s\n", from, msg)
})
```

## 联邦编排器 (Federation)

跨组织的 Agent 协作。

```go
import "github.com/BaSui01/agentflow/agent/federation"

// 创建联邦编排器
orchestrator := federation.NewFederationOrchestrator(federation.FederationConfig{
    NodeID:           "org-001",
    DiscoveryService: "consul://localhost:8500",
    AuthProvider:     authProvider,
    TLSConfig:        tlsConfig,
    MaxPeers:         50,
    HeartbeatInterval: 30 * time.Second,
}, logger)

// 启动联邦节点
orchestrator.Start(ctx)

// 发现其他组织的 Agent
peers, _ := orchestrator.DiscoverPeers(ctx)

// 跨组织任务委托
result, _ := orchestrator.Delegate(ctx, &federation.DelegationRequest{
    TargetOrg:   "org-002",
    AgentType:   "specialist",
    Task:        "执行专业分析",
    Credentials: credentials,
    Timeout:     10 * time.Minute,
})

// 注册本地 Agent 供其他组织调用
orchestrator.RegisterLocalAgent("analyst", analystAgent, federation.AccessPolicy{
    AllowedOrgs: []string{"org-002", "org-003"},
    RateLimit:   100,
    RequireAuth: true,
})
```

## Crews (CrewAI 风格团队)

基于角色的 Agent 团队协作。

```go
import "github.com/BaSui01/agentflow/agent/crews"

// 创建 Crew
crew := crews.NewCrew(crews.CrewConfig{
    Name:        "研发团队",
    Description: "负责软件开发的 Agent 团队",
    Process:     crews.ProcessSequential,  // 顺序执行
    Verbose:     true,
}, logger)

// 定义角色
crew.AddAgent(&crews.CrewAgent{
    Role:        "产品经理",
    Goal:        "定义产品需求和优先级",
    Backstory:   "你是一位经验丰富的产品经理，擅长理解用户需求",
    Agent:       pmAgent,
    AllowDelegation: true,
})

crew.AddAgent(&crews.CrewAgent{
    Role:        "架构师",
    Goal:        "设计系统架构",
    Backstory:   "你是一位资深架构师，精通分布式系统设计",
    Agent:       architectAgent,
    AllowDelegation: false,
})

crew.AddAgent(&crews.CrewAgent{
    Role:        "开发者",
    Goal:        "实现功能代码",
    Backstory:   "你是一位全栈开发者，代码质量高",
    Agent:       devAgent,
    AllowDelegation: false,
})

// 定义任务
crew.AddTask(&crews.Task{
    Description:   "分析用户反馈，提取核心需求",
    ExpectedOutput: "需求文档",
    Agent:         "产品经理",
})

crew.AddTask(&crews.Task{
    Description:   "根据需求设计技术方案",
    ExpectedOutput: "架构设计文档",
    Agent:         "架构师",
    Context:       []string{"需求文档"},  // 依赖前一个任务
})

crew.AddTask(&crews.Task{
    Description:   "实现核心功能",
    ExpectedOutput: "代码实现",
    Agent:         "开发者",
    Context:       []string{"架构设计文档"},
})

// 执行 Crew
result, _ := crew.Kickoff(ctx, "开发一个用户认证模块")

fmt.Printf("最终输出: %s\n", result.FinalOutput)
for _, taskResult := range result.TaskResults {
    fmt.Printf("任务 [%s]: %s\n", taskResult.Task, taskResult.Output)
}
```

### Crew 执行模式

```go
const (
    ProcessSequential  CrewProcess = "sequential"   // 顺序执行
    ProcessHierarchical CrewProcess = "hierarchical" // 层级执行（有管理者）
    ProcessConsensus   CrewProcess = "consensus"    // 共识执行
)
```

## 智能记忆衰减

基于重要性和访问模式的智能记忆管理。

```go
import "github.com/BaSui01/agentflow/agent/memory"

// 创建智能衰减管理器
decayManager := memory.NewIntelligentDecay(memory.DecayConfig{
    BaseDecayRate:     0.1,           // 基础衰减率
    ImportanceWeight:  0.5,           // 重要性权重
    RecencyWeight:     0.3,           // 时效性权重
    FrequencyWeight:   0.2,           // 访问频率权重
    MinRetention:      0.1,           // 最小保留阈值
    DecayInterval:     1 * time.Hour, // 衰减间隔
    ConsolidationThreshold: 0.7,      // 整合阈值
}, logger)

// 启动衰减进程
decayManager.Start(ctx)

// 添加记忆（带重要性评分）
decayManager.AddMemory(&memory.DecayableMemory{
    ID:         "mem-001",
    Content:    "用户偏好简洁回答",
    Importance: 0.8,
    CreatedAt:  time.Now(),
    AccessCount: 0,
})

// 访问记忆（更新访问统计）
mem, _ := decayManager.Access(ctx, "mem-001")

// 获取当前保留分数
score := decayManager.GetRetentionScore("mem-001")
fmt.Printf("保留分数: %.2f\n", score)

// 手动触发衰减
decayManager.Decay(ctx)

// 获取应该被清理的记忆
toRemove := decayManager.GetMemoriesForRemoval(0.2)

// 整合相似记忆
decayManager.Consolidate(ctx)
```

### 衰减策略

```go
const (
    DecayLinear      DecayStrategy = "linear"       // 线性衰减
    DecayExponential DecayStrategy = "exponential"  // 指数衰减
    DecayStepwise    DecayStrategy = "stepwise"     // 阶梯衰减
    DecayAdaptive    DecayStrategy = "adaptive"     // 自适应衰减
)
```

## 工件管理 (Artifact Manager)

Google ADK 风格的工件生命周期管理。

```go
import "github.com/BaSui01/agentflow/agent/artifacts"

// 创建工件存储
store, _ := artifacts.NewFileStore("./artifacts")

// 创建工件管理器
manager := artifacts.NewManager(artifacts.ManagerConfig{
    BasePath:   "./artifacts",
    MaxSize:    100 * 1024 * 1024, // 100MB
    DefaultTTL: 24 * time.Hour,
}, store, logger)

// 创建工件
artifact, _ := manager.Create(ctx, "analysis_result.json", artifacts.ArtifactTypeData, dataReader,
    artifacts.WithMimeType("application/json"),
    artifacts.WithTags("analysis", "report"),
    artifacts.WithSessionID(sessionID),
    artifacts.WithTTL(7 * 24 * time.Hour),
    artifacts.WithMetadata(map[string]any{
        "source": "analyzer_agent",
        "version": "1.0",
    }),
)

fmt.Printf("工件 ID: %s, 大小: %d, 校验和: %s\n", 
    artifact.ID, artifact.Size, artifact.Checksum)

// 获取工件
artifact, reader, _ := manager.Get(ctx, artifactID)
defer reader.Close()

// 列出工件
artifacts, _ := manager.List(ctx, artifacts.ArtifactQuery{
    SessionID: sessionID,
    Type:      artifacts.ArtifactTypeData,
    Tags:      []string{"report"},
})

// 创建新版本
newVersion, _ := manager.CreateVersion(ctx, artifact.ID, newDataReader)

// 归档工件
manager.Archive(ctx, artifactID)

// 清理过期工件
deleted, _ := manager.Cleanup(ctx)
```

### 工件类型

```go
const (
    ArtifactTypeFile   ArtifactType = "file"   // 通用文件
    ArtifactTypeData   ArtifactType = "data"   // 数据文件
    ArtifactTypeImage  ArtifactType = "image"  // 图片
    ArtifactTypeCode   ArtifactType = "code"   // 代码
    ArtifactTypeOutput ArtifactType = "output" // 输出结果
    ArtifactTypeModel  ArtifactType = "model"  // 模型文件
)
```

## Agentic Browser (视觉-动作循环)

基于视觉模型的浏览器自动化。

```go
import "github.com/BaSui01/agentflow/agent/browser"

// 创建 Agentic Browser
agenticBrowser := browser.NewAgenticBrowser(
    browserDriver,  // 浏览器驱动
    visionModel,    // 视觉模型（GPT-4V 等）
    browser.AgenticBrowserConfig{
        MaxActions:      50,
        ActionDelay:     500 * time.Millisecond,
        ScreenshotDelay: 200 * time.Millisecond,
        Timeout:         5 * time.Minute,
        RetryOnFailure:  true,
        MaxRetries:      3,
    },
    logger,
)

// 执行浏览器任务
result, _ := agenticBrowser.ExecuteTask(ctx, browser.BrowserTask{
    ID:       "task-001",
    Goal:     "在 GitHub 上搜索 AgentFlow 项目并获取 star 数",
    StartURL: "https://github.com",
    Instructions: []string{
        "找到搜索框",
        "输入 AgentFlow",
        "点击搜索结果",
    },
})

fmt.Printf("成功: %v, 执行动作: %d, 耗时: %v\n", 
    result.Success, len(result.Actions), result.Duration)

// 获取执行历史
history := agenticBrowser.GetHistory()
for _, record := range history {
    fmt.Printf("动作: %s, 成功: %v\n", record.Action.Type, record.Success)
}
```

### Vision-Action Loop 流程

```
1. 截图 → 2. 视觉分析 → 3. 检查目标 → 4. 规划动作 → 5. 执行动作 → 重复
```

## LSP 集成

Language Server Protocol 客户端，用于代码智能。

```go
import "github.com/BaSui01/agentflow/agent/lsp"

// 创建 LSP 客户端
client := lsp.NewLSPClient(reader, writer, logger)

// 初始化
result, _ := client.Initialize(ctx, lsp.InitializeParams{
    ProcessID: os.Getpid(),
    RootURI:   "file:///path/to/project",
    Capabilities: lsp.ClientCapabilities{
        TextDocument: lsp.TextDocumentClientCapabilities{
            Completion: &lsp.CompletionClientCapabilities{
                DynamicRegistration: true,
            },
        },
    },
})

fmt.Printf("服务器: %s\n", result.ServerInfo.Name)

// 代码补全
completions, _ := client.TextDocumentCompletion(ctx, lsp.CompletionParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Position:     lsp.Position{Line: 10, Character: 5},
})

// 悬停信息
hover, _ := client.TextDocumentHover(ctx, lsp.HoverParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Position:     lsp.Position{Line: 10, Character: 5},
})

// 跳转定义
locations, _ := client.TextDocumentDefinition(ctx, lsp.DefinitionParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Position:     lsp.Position{Line: 10, Character: 5},
})

// 查找引用
refs, _ := client.TextDocumentReferences(ctx, lsp.ReferenceParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Position:     lsp.Position{Line: 10, Character: 5},
})

// 文档符号
symbols, _ := client.TextDocumentDocumentSymbol(ctx, lsp.DocumentSymbolParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
})

// 代码操作
actions, _ := client.TextDocumentCodeAction(ctx, lsp.CodeActionParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Range:        lsp.Range{Start: lsp.Position{Line: 10}, End: lsp.Position{Line: 15}},
})

// 注册通知处理器
client.RegisterNotificationHandler("textDocument/publishDiagnostics", func(method string, params json.RawMessage) {
    fmt.Printf("收到诊断通知\n")
})

// 关闭
client.Shutdown(ctx)
```

## 长时间任务执行器

支持天级长时间任务，带检查点和恢复。

```go
import "github.com/BaSui01/agentflow/agent/longrunning"

// 创建执行器
executor := longrunning.NewExecutor(longrunning.ExecutorConfig{
    CheckpointInterval: 5 * time.Minute,
    CheckpointDir:      "./checkpoints",
    MaxRetries:         3,
    HeartbeatInterval:  30 * time.Second,
    AutoResume:         true,
}, logger)

// 定义步骤
steps := []longrunning.StepFunc{
    func(ctx context.Context, state any) (any, error) {
        // 步骤 1: 数据收集
        return collectData(ctx, state)
    },
    func(ctx context.Context, state any) (any, error) {
        // 步骤 2: 数据处理
        return processData(ctx, state)
    },
    func(ctx context.Context, state any) (any, error) {
        // 步骤 3: 生成报告
        return generateReport(ctx, state)
    },
}

// 创建执行
exec := executor.CreateExecution("数据分析任务", steps)

// 启动执行
executor.Start(ctx, exec.ID, initialState)

// 检查进度
exec, _ := executor.GetExecution(exec.ID)
fmt.Printf("进度: %.2f%%, 当前步骤: %d/%d\n", 
    exec.Progress, exec.CurrentStep, exec.TotalSteps)

// 暂停执行
executor.Pause(exec.ID)

// 恢复执行
executor.Resume(exec.ID)

// 从检查点加载
exec, _ = executor.LoadExecution(exec.ID)

// 列出所有执行
executions := executor.ListExecutions()
```

## Kubernetes Operator

Kubernetes 原生 Agent 管理，支持自动扩缩容和自愈。

```go
import "github.com/BaSui01/agentflow/agent/k8s"

// 创建 Operator
operator := k8s.NewAgentOperator(k8s.OperatorConfig{
    Namespace:               "agents",
    ReconcileInterval:       30 * time.Second,
    MetricsPort:             8080,
    HealthProbePort:         8081,
    LeaderElection:          true,
    MaxConcurrentReconciles: 3,
}, logger)

// 设置回调
operator.SetReconcileCallback(func(agent *k8s.AgentCRD) error {
    // 自定义调和逻辑
    return nil
})

operator.SetScaleCallback(func(agent *k8s.AgentCRD, replicas int32) error {
    // 自定义扩缩容逻辑
    return nil
})

operator.SetHealthCheckCallback(func(agent *k8s.AgentCRD) (bool, error) {
    // 自定义健康检查
    return true, nil
})

// 启动 Operator
operator.Start(ctx)

// 注册 Agent CRD
operator.RegisterAgent(&k8s.AgentCRD{
    APIVersion: "agentflow.io/v1",
    Kind:       "Agent",
    Metadata: k8s.ObjectMeta{
        Name:      "assistant",
        Namespace: "agents",
        Labels:    map[string]string{"app": "assistant"},
    },
    Spec: k8s.AgentSpec{
        AgentType: "assistant",
        Replicas:  3,
        Model: k8s.ModelSpec{
            Provider:    "openai",
            Model:       "gpt-4o",
            Temperature: 0.7,
        },
        Resources: k8s.ResourceSpec{
            Requests: k8s.ResourceQuantity{CPU: "100m", Memory: "256Mi"},
            Limits:   k8s.ResourceQuantity{CPU: "500m", Memory: "512Mi"},
        },
        Scaling: k8s.ScalingSpec{
            Enabled:     true,
            MinReplicas: 1,
            MaxReplicas: 10,
            TargetMetrics: []k8s.TargetMetric{
                {Type: "requests_per_second", TargetValue: 100},
                {Type: "latency", TargetValue: 500},
            },
        },
        HealthCheck: k8s.HealthCheckSpec{
            Enabled:          true,
            Interval:         10 * time.Second,
            Timeout:          5 * time.Second,
            FailureThreshold: 3,
        },
    },
})

// 获取 Agent 状态
agent := operator.GetAgent("agents", "assistant")
fmt.Printf("阶段: %s, 副本: %d/%d\n", 
    agent.Status.Phase, agent.Status.ReadyReplicas, agent.Spec.Replicas)

// 获取实例
instances := operator.GetInstances("agents", "assistant")

// 更新实例指标
operator.UpdateInstanceMetrics(instanceID, k8s.InstanceMetrics{
    RequestsPerSecond: 50,
    AverageLatency:    200 * time.Millisecond,
    CPUUsage:          0.3,
    MemoryUsage:       0.5,
})

// 导出/导入 CRD
crdJSON, _ := operator.ExportCRD("agents", "assistant")
operator.ImportCRD(crdJSON)

// 停止 Operator
operator.Stop()
```

## 可观测性系统

完整的指标收集、追踪和评估系统。

```go
import "github.com/BaSui01/agentflow/agent/observability"

// 创建可观测性系统
obsSystem := observability.NewObservabilitySystem(logger)

// 记录任务指标
obsSystem.metricsCollector.RecordTask(
    agentID,
    true,                    // 成功
    500 * time.Millisecond,  // 延迟
    1000,                    // Token 数
    0.05,                    // 成本
    0.85,                    // 质量分数
)

// 获取指标
metrics := obsSystem.metricsCollector.GetMetrics(agentID)
fmt.Printf("成功率: %.2f%%, 平均延迟: %v, P95: %v\n", 
    metrics.TaskSuccessRate * 100, metrics.AvgLatency, metrics.P95Latency)

// 开始追踪
trace := obsSystem.tracer.StartTrace(traceID, agentID)

// 添加 Span
obsSystem.tracer.AddSpan(traceID, &observability.Span{
    SpanID:    "span-1",
    Name:      "tool_execution",
    StartTime: time.Now(),
    Attributes: map[string]interface{}{
        "tool_name": "search",
    },
})

// 结束追踪
obsSystem.tracer.EndTrace(traceID, "completed", nil)

// 获取追踪
trace = obsSystem.tracer.GetTrace(traceID)

// 注册基准测试
obsSystem.evaluator.RegisterBenchmark(&observability.Benchmark{
    Name:        "qa_benchmark",
    Description: "问答质量基准测试",
    Dataset: []observability.BenchmarkCase{
        {ID: "case-1", Input: input1, ExpectedOutput: "expected1"},
        {ID: "case-2", Input: input2, ExpectedOutput: "expected2"},
    },
})

// 运行基准测试
result, _ := obsSystem.evaluator.RunBenchmark(ctx, "qa_benchmark", myAgent)
fmt.Printf("成功率: %.2f%%, 平均分: %.2f\n", 
    result.SuccessRate * 100, result.AvgScore)
```

## 决策可解释性

追踪和解释 Agent 决策过程。

```go
import "github.com/BaSui01/agentflow/agent/observability"

// 创建可解释性追踪器
tracker := observability.NewExplainabilityTracker(observability.ExplainabilityConfig{
    Enabled:            true,
    DetailLevel:        "verbose",
    MaxTraceAge:        24 * time.Hour,
    MaxTracesPerAgent:  100,
    RecordAlternatives: true,
    RecordFactors:      true,
})

// 开始推理追踪
trace := tracker.StartTrace(sessionID, agentID)

// 添加推理步骤
tracker.AddStep(trace.ID, observability.ReasoningStep{
    Type:    "thought",
    Content: "用户询问代码优化，需要分析代码结构",
})

// 记录决策
tracker.RecordDecision(trace.ID, observability.Decision{
    Type:        observability.DecisionToolSelection,
    Description: "选择代码分析工具",
    Reasoning:   "任务涉及代码分析，code_analyzer 工具最适合",
    Confidence:  0.9,
    Factors: []observability.Factor{
        {Name: "任务相关性", Value: 0.95, Weight: 0.5, Impact: "positive"},
        {Name: "工具可靠性", Value: 0.88, Weight: 0.3, Impact: "positive"},
    },
    Alternatives: []observability.Alternative{
        {Option: "code_analyzer", Score: 0.9, WasChosen: true},
        {Option: "search", Score: 0.6, WasChosen: false, Reason: "不够专业"},
    },
})

// 结束追踪
tracker.EndTrace(trace.ID, true, "分析完成", "")

// 生成决策解释
explanation := tracker.ExplainDecision(decision)
fmt.Println(explanation)

// 生成审计报告
report, _ := tracker.GenerateAuditReport(trace.ID)
reportJSON, _ := report.Export()
```

## Agent 注册表

集中管理 Agent 类型和工厂。

```go
import "github.com/BaSui01/agentflow/agent"

// 初始化全局注册表
agent.InitGlobalRegistry(logger)

// 注册自定义 Agent 类型
agent.RegisterAgentType("custom_analyzer", func(
    config agent.Config,
    provider llm.Provider,
    memory agent.MemoryManager,
    toolManager agent.ToolManager,
    bus agent.EventBus,
    logger *zap.Logger,
) (agent.Agent, error) {
    // 创建自定义 Agent
    baseAgent := agent.NewBaseAgent(config, provider, memory, toolManager, bus, logger)
    // 添加自定义逻辑
    return baseAgent, nil
})

// 使用注册表创建 Agent
myAgent, _ := agent.CreateAgent(
    agent.Config{
        ID:   "analyzer-001",
        Name: "代码分析器",
        Type: "custom_analyzer",
    },
    provider, memory, toolManager, bus, logger,
)

// 检查类型是否已注册
if agent.GlobalRegistry.IsRegistered("custom_analyzer") {
    fmt.Println("类型已注册")
}

// 列出所有注册的类型
types := agent.GlobalRegistry.ListTypes()
```

## 部署系统

支持多种部署目标的 Agent 部署。

```go
import "github.com/BaSui01/agentflow/agent/deployment"

// 创建部署器
deployer := deployment.NewDeployer(deployment.DeployerConfig{
    Registry:     "docker.io/myorg",
    BuildTimeout: 10 * time.Minute,
    PushTimeout:  5 * time.Minute,
}, logger)

// 构建 Agent 镜像
image, _ := deployer.BuildImage(ctx, &deployment.BuildConfig{
    AgentID:    "assistant-001",
    BaseImage:  "golang:1.24-alpine",
    Dockerfile: dockerfileContent,
    Tags:       []string{"v1.0.0", "latest"},
})

// 部署到 Kubernetes
deployer.DeployToK8s(ctx, &deployment.K8sDeployConfig{
    Namespace:   "agents",
    Replicas:    3,
    Image:       image,
    Resources: deployment.Resources{
        CPURequest:    "100m",
        CPULimit:      "500m",
        MemoryRequest: "128Mi",
        MemoryLimit:   "512Mi",
    },
    Env: map[string]string{
        "OPENAI_API_KEY": "${OPENAI_API_KEY}",
    },
    Ports: []int{8080, 9090},
    HealthCheck: &deployment.HealthCheck{
        Path:     "/health",
        Port:     8080,
        Interval: 30 * time.Second,
    },
})

// 部署到 Cloud Run
deployer.DeployToCloudRun(ctx, &deployment.CloudRunConfig{
    Project:     "my-project",
    Region:      "us-central1",
    ServiceName: "agent-assistant",
    Image:       image,
    MaxInstances: 10,
    MinInstances: 1,
    Memory:      "512Mi",
    CPU:         "1",
    Concurrency: 80,
})

// 部署到 AWS Lambda
deployer.DeployToLambda(ctx, &deployment.LambdaConfig{
    FunctionName: "agent-assistant",
    Runtime:      "provided.al2",
    Handler:      "bootstrap",
    MemorySize:   512,
    Timeout:      30,
    Environment: map[string]string{
        "AGENT_ID": "assistant-001",
    },
})
```

## 检查点和恢复

```go
import "github.com/BaSui01/agentflow/agent/checkpoint"

// 创建检查点管理器
checkpointer := checkpoint.NewCheckpointer(checkpoint.Config{
    Storage:     "redis",
    Prefix:      "agent_checkpoint:",
    TTL:         24 * time.Hour,
    Compression: true,
})

// 保存检查点
checkpointer.Save(ctx, &checkpoint.Checkpoint{
    AgentID:   agentID,
    State:     agentState,
    Memory:    memorySnapshot,
    Timestamp: time.Now(),
})

// 恢复检查点
cp, _ := checkpointer.Load(ctx, agentID)
agent.RestoreFromCheckpoint(cp)
```

## 最佳实践

1. **使用 Builder 模式**：清晰配置 Agent 各项功能
2. **启用安全护栏**：生产环境必须启用输入验证和输出过滤
3. **合理配置记忆**：根据场景选择合适的记忆类型和容量
4. **技能模块化**：将复杂能力拆分为独立技能
5. **事件监控**：订阅关键事件进行监控和调试
6. **检查点保护**：长任务启用检查点防止数据丢失
7. **推理模式选择**：
   - 简单问题：直接回答
   - 复杂推理：Tree of Thought
   - 工具密集：ReWOO
   - 需要改进：Reflexion
   - 长流程：Plan-and-Execute
8. **Human-in-the-Loop**：敏感操作启用人工审批
9. **异步执行**：长任务使用异步执行避免阻塞
10. **沙箱执行**：AI 生成的代码必须在沙箱中运行
11. **防御性提示**：启用提示注入防护和输出验证
12. **模块化提示词**：使用 PromptBundle 管理提示词版本
13. **层级架构**：复杂系统使用 Supervisor-Worker 模式
14. **多 Agent 协作**：根据任务选择合适的协作模式（辩论/共识/流水线）
15. **Crews 团队**：基于角色定义清晰的职责分工
16. **智能记忆管理**：启用智能衰减避免记忆膨胀
17. **联邦协作**：跨组织场景使用联邦编排器
18. **容器化部署**：生产环境使用 K8s 或云服务部署
