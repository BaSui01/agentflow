# 检索增强 (RAG)

AgentFlow 的 RAG 能力位于 `github.com/BaSui01/agentflow/rag`，包含：文档分块、混合检索（BM25 + 向量）、上下文检索、GraphRAG、向量存储接口与若干实现。

## 支持情况（后端/接口）

### 向量存储（VectorStore）

| 后端 | 状态 | 说明 |
|------|------|------|
| In-memory | ✅ 已实现 | 适用于测试/小规模数据 |
| Qdrant | ✅ 已实现 | REST 客户端（支持可选 `AutoCreateCollection`） |
| Pinecone | ✅ 已实现 | REST 客户端（支持通过 controller API 自动解析 host） |

### 其他组件

- **Embedding Provider**：`llm/embedding` ✅ 已实现（OpenAI/Cohere/Voyage/Jina/Gemini…）
- **Rerank Provider**：`llm/rerank` ✅ 已实现（Cohere/Voyage/Jina…）
- **GraphRAG**：✅ 核心逻辑已实现，但需要你提供 `GraphVectorStore`/`GraphEmbedder`（接口）

## 混合检索

结合 BM25 和向量检索的混合检索器：

```go
import "github.com/BaSui01/agentflow/rag"

retriever := rag.NewHybridRetriever(rag.DefaultHybridRetrievalConfig(), logger)

docs := []rag.Document{
    {
        ID:        "doc1",
        Content:   "Go 是一种静态类型的编译语言...",
        Metadata:  map[string]interface{}{"source": "wiki"},
        Embedding: embedding1,
    },
    {
        ID:        "doc2",
        Content:   "并发是 Go 的核心特性之一...",
        Metadata:  map[string]interface{}{"source": "blog"},
        Embedding: embedding2,
    },
}

_ = retriever.IndexDocuments(docs)

results, err := retriever.Retrieve(ctx, "Go 并发编程", queryEmbedding)
if err != nil {
    // handle err
}

for _, r := range results {
    fmt.Printf("文档: %s\n", r.Document.ID)
    fmt.Printf("最终分数: %.3f\n", r.FinalScore)
}
```

## 向量存储

### 内置内存向量存储（可运行）

```go
import "github.com/BaSui01/agentflow/rag"

vectorStore := rag.NewInMemoryVectorStore(logger)
retriever := rag.NewHybridRetrieverWithVectorStore(rag.DefaultHybridRetrievalConfig(), vectorStore, logger)
```

### Qdrant（已支持后端）

```go
vectorStore := rag.NewQdrantStore(rag.QdrantConfig{
    Host:                 "localhost",
    Port:                 6333,
    Collection:           "documents",
    AutoCreateCollection: true,
}, logger)
```

### Pinecone（已支持后端）

```go
vectorStore := rag.NewPineconeStore(rag.PineconeConfig{
    APIKey: os.Getenv("PINECONE_API_KEY"),
    Index:  "documents",
}, logger)
```

## Embedding 提供商（已支持）

```go
import "github.com/BaSui01/agentflow/llm/embedding"

embedder := embedding.NewOpenAIProvider(embedding.OpenAIConfig{
    APIKey: os.Getenv("OPENAI_API_KEY"),
    Model:  "text-embedding-3-large",
})

vector, err := embedder.EmbedQuery(ctx, "Go 并发编程")
vectors, err := embedder.EmbedDocuments(ctx, []string{"文本 1", "文本 2", "文本 3"})
```

## 重排序（已支持）

```go
import "github.com/BaSui01/agentflow/llm/rerank"

reranker := rerank.NewCohereProvider(rerank.CohereConfig{
    APIKey: os.Getenv("COHERE_API_KEY"),
    Model:  "rerank-multilingual-v3.0",
})

reranked, err := reranker.RerankSimple(ctx, query, documents, 10)
```

## 文档分块（已支持）

```go
import "github.com/BaSui01/agentflow/rag"

chunker := rag.NewDocumentChunker(rag.DefaultChunkingConfig(), &rag.SimpleTokenizer{}, logger)
chunks := chunker.ChunkDocument(rag.Document{ID: "doc1", Content: longDocument})
```

## 上下文检索（接口/示例）

`rag.NewContextualRetrieval(...)` 已实现，但需要你提供 `ContextProvider`（例如用 LLM 为每个 chunk 生成文档级上下文）。

## 图 RAG（接口/示例）

`rag.NewGraphRAG(...)` 已实现核心逻辑，但需要你提供 `GraphVectorStore`/`GraphEmbedder` 的具体实现（例如对接向量库和 embedding）。

## 上下文管理（已支持）

AgentFlow 的上下文工程位于 `agent/context`，提供自动压缩/截断能力：

```go
import agentcontext "github.com/BaSui01/agentflow/agent/context"

engineer := agentcontext.New(agentcontext.DefaultConfig(), logger)
trimmedMsgs, err := engineer.MustFit(ctx, messages, currentQuery)
```

> 注：更细粒度的“按策略裁剪（滑窗/按角色/按重要性）”API 与 LLM 摘要压缩接口已预留，但当前版本未以 `PruneByStrategy` 形式对外暴露。

## 完整可运行示例

参考：`examples/12_complete_rag_system/main.go`
