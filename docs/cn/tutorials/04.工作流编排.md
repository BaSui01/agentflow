# 工作流编排

AgentFlow 提供多种工作流模式，支持链式、并行、DAG、条件路由、循环、子图、检查点等复杂任务编排。

## 链式工作流

按顺序执行步骤，前一步的输出作为后一步的输入：

```go
import "github.com/BaSui01/agentflow/workflow"

// 定义步骤
step1 := workflow.NewFuncStep("提取", func(ctx context.Context, input interface{}) (interface{}, error) {
    text := input.(string)
    return extractKeywords(text), nil
})

step2 := workflow.NewFuncStep("分析", func(ctx context.Context, input interface{}) (interface{}, error) {
    keywords := input.([]string)
    return analyzeKeywords(keywords), nil
})

step3 := workflow.NewFuncStep("生成", func(ctx context.Context, input interface{}) (interface{}, error) {
    analysis := input.(Analysis)
    return generateReport(analysis), nil
})

// 创建链式工作流
chain := workflow.NewChainWorkflow(
    "文本分析流程",
    "提取关键词 → 分析 → 生成报告",
    step1, step2, step3,
)

// 执行
result, err := chain.Execute(ctx, "输入文本...")
```

## 并行工作流

并发执行多个任务，汇总结果：

```go
// 创建并行工作流
parallel := workflow.NewParallelWorkflow("并行处理", "同时执行多个分析")

parallel.AddBranch("情感分析", sentimentStep)
parallel.AddBranch("实体识别", nerStep)
parallel.AddBranch("关键词提取", keywordStep)

// 执行 - 所有分支并发运行
results, err := parallel.Execute(ctx, inputText)
// results 是 map[string]interface{}，包含每个分支的结果

fmt.Printf("情感: %v\n", results["情感分析"])
fmt.Printf("实体: %v\n", results["实体识别"])
fmt.Printf("关键词: %v\n", results["关键词提取"])
```

## DAG 工作流

有向无环图，支持复杂依赖关系：

### 基础 DAG

```go
// 使用 Builder 创建 DAG
dag := workflow.NewDAGBuilder("复杂流程").
    AddNode("input", workflow.NodeTypeAction, inputStep).
    AddNode("process", workflow.NodeTypeAction, processStep).
    AddNode("output", workflow.NodeTypeAction, outputStep).
    AddEdge("input", "process").
    AddEdge("process", "output").
    Build()

// 执行
executor := workflow.NewDAGExecutor(nil, logger)
result, err := executor.Execute(ctx, dag, initialInput)
```

### 条件节点

```go
dag := workflow.NewDAGBuilder("条件流程").
    AddNode("input", workflow.NodeTypeAction, inputStep).
    AddNode("check", workflow.NodeTypeCondition, nil).
    AddNode("pathA", workflow.NodeTypeAction, pathAStep).
    AddNode("pathB", workflow.NodeTypeAction, pathBStep).
    AddNode("merge", workflow.NodeTypeAction, mergeStep).
    AddEdge("input", "check").
    AddEdge("check", "pathA").
    AddEdge("check", "pathB").
    AddEdge("pathA", "merge").
    AddEdge("pathB", "merge").
    SetCondition("check", func(ctx context.Context, input interface{}) (bool, error) {
        data := input.(Data)
        return data.Score > 0.5, nil
    }).
    SetNodeMetadata("check", map[string]interface{}{
        "on_true":  []string{"pathA"},
        "on_false": []string{"pathB"},
    }).
    Build()
```

### 循环节点

```go
// While 循环
dag := workflow.NewDAGBuilder("迭代优化").
    AddNode("init", workflow.NodeTypeAction, initStep).
    AddNode("loop", workflow.NodeTypeLoop, nil).
    AddNode("process", workflow.NodeTypeAction, processStep).
    AddEdge("init", "loop").
    AddEdge("loop", "process").
    SetLoopConfig("loop", &workflow.LoopConfig{
        Type:          workflow.LoopTypeWhile,
        MaxIterations: 10,
        Condition: func(ctx context.Context, input interface{}) (bool, error) {
            result := input.(Result)
            return result.Quality < 0.9, nil // 质量未达标时继续循环
        },
    }).
    Build()

// For 循环（固定次数）
dag := workflow.NewDAGBuilder("批处理").
    AddNode("loop", workflow.NodeTypeLoop, nil).
    AddNode("batch", workflow.NodeTypeAction, batchStep).
    AddEdge("loop", "batch").
    SetLoopConfig("loop", &workflow.LoopConfig{
        Type:          workflow.LoopTypeFor,
        MaxIterations: 5, // 执行 5 次
    }).
    Build()

// ForEach 循环（遍历集合）
dag := workflow.NewDAGBuilder("遍历处理").
    AddNode("loop", workflow.NodeTypeLoop, nil).
    AddNode("item", workflow.NodeTypeAction, itemStep).
    AddEdge("loop", "item").
    SetLoopConfig("loop", &workflow.LoopConfig{
        Type:          workflow.LoopTypeForEach,
        MaxIterations: 100, // 最多处理 100 项
        Iterator: func(ctx context.Context, input interface{}) ([]interface{}, error) {
            data := input.([]Item)
            items := make([]interface{}, len(data))
            for i, item := range data {
                items[i] = item
            }
            return items, nil
        },
    }).
    Build()
```

### 并行节点

```go
dag := workflow.NewDAGBuilder("并行处理").
    AddNode("split", workflow.NodeTypeAction, splitStep).
    AddNode("parallel", workflow.NodeTypeParallel, nil).
    AddNode("taskA", workflow.NodeTypeAction, taskAStep).
    AddNode("taskB", workflow.NodeTypeAction, taskBStep).
    AddNode("taskC", workflow.NodeTypeAction, taskCStep).
    AddNode("merge", workflow.NodeTypeAction, mergeStep).
    AddEdge("split", "parallel").
    AddEdge("parallel", "taskA").
    AddEdge("parallel", "taskB").
    AddEdge("parallel", "taskC").
    AddEdge("taskA", "merge").
    AddEdge("taskB", "merge").
    AddEdge("taskC", "merge").
    Build()
```

### 子图节点

```go
// 创建子图
subGraph := workflow.NewDAGBuilder("子流程").
    AddNode("sub1", workflow.NodeTypeAction, sub1Step).
    AddNode("sub2", workflow.NodeTypeAction, sub2Step).
    AddEdge("sub1", "sub2").
    Build()

// 主图引用子图
dag := workflow.NewDAGBuilder("主流程").
    AddNode("main1", workflow.NodeTypeAction, main1Step).
    AddNode("sub", workflow.NodeTypeSubGraph, nil).
    AddNode("main2", workflow.NodeTypeAction, main2Step).
    AddEdge("main1", "sub").
    AddEdge("sub", "main2").
    SetSubGraph("sub", subGraph).
    Build()
```

## 错误处理

### 错误策略

```go
dag := workflow.NewDAGBuilder("带容错的流程").
    AddNode("risky", workflow.NodeTypeAction, riskyStep).
    SetErrorConfig("risky", &workflow.ErrorConfig{
        Strategy:      workflow.ErrorStrategyRetry,  // 重试策略
        MaxRetries:    3,                            // 最多重试 3 次
        RetryDelayMs:  1000,                         // 重试间隔 1 秒
        FallbackValue: defaultResult,                // 失败后的默认值
    }).
    Build()
```

### 策略类型

| 策略 | 说明 |
|------|------|
| `ErrorStrategyFailFast` | 立即失败（默认） |
| `ErrorStrategySkip` | 跳过失败节点，使用默认值继续 |
| `ErrorStrategyRetry` | 重试指定次数 |

## 检查点

长流程支持检查点，可从中断处恢复：

```go
// 创建检查点管理器
checkpointMgr := workflow.NewCheckpointManager(workflow.CheckpointConfig{
    Storage: "redis",
    TTL:     24 * time.Hour,
})

// 在 DAG 中添加检查点节点
dag := workflow.NewDAGBuilder("长流程").
    AddNode("step1", workflow.NodeTypeAction, step1).
    AddNode("checkpoint1", workflow.NodeTypeCheckpoint, nil).
    AddNode("step2", workflow.NodeTypeAction, step2).
    AddNode("checkpoint2", workflow.NodeTypeCheckpoint, nil).
    AddNode("step3", workflow.NodeTypeAction, step3).
    AddEdge("step1", "checkpoint1").
    AddEdge("checkpoint1", "step2").
    AddEdge("step2", "checkpoint2").
    AddEdge("checkpoint2", "step3").
    Build()

// 使用检查点管理器执行
executor := workflow.NewDAGExecutor(checkpointMgr, logger)
result, err := executor.Execute(ctx, dag, input)

// 从检查点恢复
if err != nil {
    // 获取最近的检查点
    checkpoint, _ := checkpointMgr.GetLatest(ctx, executionID)
    
    // 从检查点恢复执行
    result, err = executor.ResumeFromCheckpoint(ctx, dag, checkpoint)
}
```

## 执行历史

```go
executor := workflow.NewDAGExecutor(nil, logger)
result, err := executor.Execute(ctx, dag, input)

// 获取执行历史
history := executor.GetHistory()

fmt.Printf("执行 ID: %s\n", history.ExecutionID)
fmt.Printf("状态: %s\n", history.Status)
fmt.Printf("开始时间: %v\n", history.StartTime)
fmt.Printf("结束时间: %v\n", history.EndTime)

// 查看节点执行详情
for _, node := range history.Nodes {
    fmt.Printf("节点 %s: %s, 耗时 %v\n", 
        node.NodeID, node.Status, node.Duration)
}

// 持久化历史
historyStore := executor.GetHistoryStore()
historyStore.Save(history)

// 查询历史记录
histories, _ := historyStore.Query(workflow.HistoryQuery{
    WorkflowID: "my-workflow",
    Status:     "completed",
    Limit:      10,
})
```

## 路由工作流

动态选择处理器：

```go
router := workflow.NewRoutingWorkflow("智能路由", "根据输入类型选择处理器")

// 注册处理器
router.RegisterHandler("text", textHandler)
router.RegisterHandler("image", imageHandler)
router.RegisterHandler("audio", audioHandler)

// 设置路由函数
router.SetRouter(func(ctx context.Context, input interface{}) (string, error) {
    data := input.(InputData)
    return data.Type, nil // 返回处理器名称
})

// 执行
result, err := router.Execute(ctx, input)
```

## 状态管理

### State Reducer

```go
// 创建状态 Reducer
reducer := workflow.NewStateReducer(workflow.ReducerConfig{
    InitialState: map[string]interface{}{
        "count":  0,
        "items":  []string{},
        "status": "pending",
    },
})

// 定义 Reducer 函数
reducer.Register("increment", func(state, action interface{}) interface{} {
    s := state.(map[string]interface{})
    s["count"] = s["count"].(int) + 1
    return s
})

reducer.Register("add_item", func(state, action interface{}) interface{} {
    s := state.(map[string]interface{})
    item := action.(string)
    s["items"] = append(s["items"].([]string), item)
    return s
})

// 在工作流中使用
step := workflow.NewFuncStep("process", func(ctx context.Context, input interface{}) (interface{}, error) {
    reducer.Dispatch("increment", nil)
    reducer.Dispatch("add_item", "new item")
    return reducer.GetState(), nil
})
```

## DAG 序列化

```go
// 序列化 DAG 为 JSON
jsonData, err := workflow.SerializeDAG(dag)

// 从 JSON 反序列化
loadedDAG, err := workflow.DeserializeDAG(jsonData)

// 保存到文件
workflow.SaveDAGToFile(dag, "workflow.json")

// 从文件加载
dag, err := workflow.LoadDAGFromFile("workflow.json")
```

## 可视化

```go
import "github.com/BaSui01/agentflow/workflow"

// 生成 Mermaid 图
mermaid := workflow.GenerateMermaid(dag)
fmt.Println(mermaid)

// 输出示例:
// graph TD
//     input[input] --> process[process]
//     process --> output[output]

// 生成 DOT 格式（Graphviz）
dot := workflow.GenerateDOT(dag)
```

## 最佳实践

1. **合理拆分节点**：每个节点职责单一，便于复用和测试
2. **设置超时**：为长时间运行的节点设置超时
3. **使用检查点**：长流程必须添加检查点
4. **错误处理**：为关键节点配置重试和回退策略
5. **监控执行**：记录执行历史，便于问题排查
6. **避免循环依赖**：DAG 不允许循环，使用循环节点实现迭代
7. **并行优化**：独立任务使用并行节点提高效率

## 高级特性

### DAG Builder 流式 API

```go
// 使用流式 API 构建 DAG
workflow, err := workflow.NewDAGBuilder("复杂流程").
    WithDescription("多步骤数据处理流程").
    WithLogger(logger).
    AddNode("input", workflow.NodeTypeAction).
        WithStep(inputStep).
        Done().
    AddNode("validate", workflow.NodeTypeCondition).
        WithCondition(validateFunc).
        WithOnTrue("process").
        WithOnFalse("reject").
        Done().
    AddNode("process", workflow.NodeTypeAction).
        WithStep(processStep).
        WithErrorConfig(workflow.ErrorConfig{
            Strategy:   workflow.ErrorStrategyRetry,
            MaxRetries: 3,
        }).
        Done().
    AddNode("reject", workflow.NodeTypeAction).
        WithStep(rejectStep).
        Done().
    AddNode("output", workflow.NodeTypeAction).
        WithStep(outputStep).
        Done().
    AddEdge("input", "validate").
    AddEdge("process", "output").
    AddEdge("reject", "output").
    SetEntry("input").
    Build()
```

### 节点类型

| 类型 | 说明 |
|------|------|
| `NodeTypeAction` | 执行步骤 |
| `NodeTypeCondition` | 条件分支 |
| `NodeTypeLoop` | 循环迭代 |
| `NodeTypeParallel` | 并行执行 |
| `NodeTypeSubGraph` | 嵌套子图 |
| `NodeTypeCheckpoint` | 检查点 |

### 循环类型

| 类型 | 说明 |
|------|------|
| `LoopTypeWhile` | 条件循环 |
| `LoopTypeFor` | 固定次数循环 |
| `LoopTypeForEach` | 遍历集合 |

### 执行上下文

```go
// 执行上下文用于检查点和状态恢复
type ExecutionContext struct {
    WorkflowID     string                 // 工作流 ID
    CurrentNode    string                 // 当前节点
    NodeResults    map[string]interface{} // 节点结果
    Variables      map[string]interface{} // 工作流变量
    StartTime      time.Time              // 开始时间
    LastUpdateTime time.Time              // 最后更新时间
}

// 创建执行上下文
execCtx := workflow.NewExecutionContext("workflow-123")
execCtx.SetVariable("input", inputData)
execCtx.SetCurrentNode("process")
```

### DAG 验证

Builder 自动验证 DAG：
- 检查是否有节点
- 检查入口节点是否存在
- 检查边是否引用存在的节点
- 检测循环依赖
- 检测孤立节点（从入口不可达）
- 验证节点配置（Action 需要 Step，Condition 需要条件函数等）

```go
workflow, err := builder.Build()
if err != nil {
    // 验证失败
    log.Printf("DAG 验证失败: %v", err)
}
```

### 循环深度保护

DAG 执行器内置循环深度保护，防止无限循环：

```go
const maxLoopDepth = 1000

// 超过最大深度时返回错误
// "loop node xxx exceeded max depth 1000, possible infinite loop"
```
