# 工具集成说明

AgentFlow 提供完整的工具系统，支持工具注册、执行、ReAct 循环、并行执行、速率限制等功能。

## 工具注册

### 创建工具注册中心

```go
import (
    "github.com/BaSui01/agentflow/llm"
    "github.com/BaSui01/agentflow/llm/tools"
)

// 创建工具注册中心
registry := tools.NewDefaultRegistry(logger)
```

### 注册工具

```go
// 定义工具函数
searchFunc := func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Query string `json:"query"`
        Limit int    `json:"limit,omitempty"`
    }
    if err := json.Unmarshal(args, &params); err != nil {
        return nil, err
    }
    
    // 执行搜索逻辑
    results := doSearch(params.Query, params.Limit)
    return json.Marshal(results)
}

// 注册工具
registry.Register("search", searchFunc, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "search",
        Description: "搜索互联网获取信息",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "搜索关键词"
                },
                "limit": {
                    "type": "integer",
                    "description": "返回结果数量",
                    "default": 10
                }
            },
            "required": ["query"]
        }`),
    },
    Timeout:     30 * time.Second,
    Description: "使用搜索引擎查找信息",
})
```

### 速率限制

```go
registry.Register("api_call", apiFunc, tools.ToolMetadata{
    Schema: schema,
    RateLimit: &tools.RateLimitConfig{
        MaxCalls: 10,           // 最大调用次数
        Window:   time.Minute,  // 时间窗口
    },
    Timeout: 60 * time.Second,
})
```

### 工具管理

```go
// 检查工具是否存在
if registry.Has("search") {
    // 工具已注册
}

// 获取工具
fn, metadata, err := registry.Get("search")

// 列出所有工具
schemas := registry.List()

// 注销工具
registry.Unregister("search")
```

## 工具执行器

### 基础执行

```go
// 创建执行器
executor := tools.NewDefaultExecutor(registry, logger)

// 执行单个工具调用
result := executor.ExecuteOne(ctx, llm.ToolCall{
    ID:        "call_1",
    Name:      "search",
    Arguments: json.RawMessage(`{"query": "Go 语言教程"}`),
})

if result.Error != "" {
    log.Printf("工具执行失败: %s", result.Error)
} else {
    log.Printf("结果: %s", result.Result)
}
```

### 批量执行（并行）

```go
// 执行多个工具调用（自动并行）
results := executor.Execute(ctx, []llm.ToolCall{
    {
        ID:        "call_1",
        Name:      "search",
        Arguments: json.RawMessage(`{"query": "Go 并发"}`),
    },
    {
        ID:        "call_2",
        Name:      "read_file",
        Arguments: json.RawMessage(`{"path": "main.go"}`),
    },
})

for _, result := range results {
    if result.Error != "" {
        log.Printf("工具 %s 失败: %s", result.Name, result.Error)
    } else {
        log.Printf("工具 %s 成功: %s", result.Name, result.Result)
    }
}
```

## ReAct 执行器

ReAct (Reasoning + Acting) 模式自动处理 LLM → Tool → LLM 循环：

### 基础 ReAct

```go
// 创建 ReAct 执行器
reactExecutor := tools.NewReActExecutor(
    provider,
    executor,
    tools.ReActConfig{
        MaxIterations: 10,      // 最大迭代次数
        StopOnError:   false,   // 错误时是否停止
        Verbose:       true,    // 详细日志
    },
    logger,
)

// 执行 ReAct 循环
req := &llm.ChatRequest{
    Model: "gpt-4o",
    Messages: []llm.Message{
        {Role: llm.RoleUser, Content: "搜索最新的 Go 1.24 特性并总结"},
    },
    Tools: registry.List(),
}

response, steps, err := reactExecutor.Execute(ctx, req)
if err != nil {
    log.Fatal(err)
}

// 查看执行步骤
for _, step := range steps {
    log.Printf("步骤 %d: %s", step.StepNumber, step.Thought)
    if step.Action != "" {
        log.Printf("  动作: %s(%s)", step.Action, step.ActionInput)
    }
    if step.Observation != "" {
        log.Printf("  观察: %s", step.Observation)
    }
}

fmt.Printf("最终答案: %s\n", response.Choices[0].Message.Content)
```

### 流式 ReAct

```go
eventCh, err := reactExecutor.ExecuteStream(ctx, req)
if err != nil {
    log.Fatal(err)
}

for event := range eventCh {
    switch event.Type {
    case "thinking":
        fmt.Printf("思考: %s\n", event.Content)
    case "llm_chunk":
        fmt.Print(event.Chunk.Delta.Content)
    case "tools_start":
        fmt.Printf("\n开始执行工具: %v\n", event.ToolCalls)
    case "tool_result":
        fmt.Printf("工具结果: %s\n", event.ToolResult)
    case "tools_end":
        fmt.Printf("工具执行完成\n")
    case "completed":
        fmt.Println("\n执行完成")
    case "error":
        fmt.Printf("错误: %s\n", event.Error)
    }
}
```

## 并行工具执行

### 显式并行

```go
import "github.com/BaSui01/agentflow/llm/tools"

parallelExecutor := tools.NewParallelExecutor(executor, tools.ParallelConfig{
    MaxConcurrency: 5,           // 最大并发数
    Timeout:        60 * time.Second,
})

results := parallelExecutor.Execute(ctx, toolCalls)
```

### 工具依赖管理

```go
// 定义工具依赖关系
deps := tools.NewDependencyGraph()
deps.AddDependency("analyze", "fetch_data")  // analyze 依赖 fetch_data
deps.AddDependency("report", "analyze")      // report 依赖 analyze

// 按依赖顺序执行
orderedExecutor := tools.NewOrderedExecutor(executor, deps)
results := orderedExecutor.Execute(ctx, toolCalls)
```

## 工具回退

当主工具失败时自动使用备用工具：

```go
import "github.com/BaSui01/agentflow/llm/tools"

// 创建回退执行器
fallbackExecutor := tools.NewFallbackExecutor(executor, tools.FallbackConfig{
    Fallbacks: map[string][]string{
        "search":    {"search_backup", "web_scrape"},
        "translate": {"translate_backup", "llm_translate"},
    },
    MaxRetries: 2,
})

// 执行时自动回退
result := fallbackExecutor.ExecuteOne(ctx, toolCall)
```

## 常用工具示例

### 文件操作

```go
// 读取文件
registry.Register("read_file", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Path string `json:"path"`
    }
    json.Unmarshal(args, &params)
    
    content, err := os.ReadFile(params.Path)
    if err != nil {
        return nil, err
    }
    
    return json.Marshal(map[string]string{"content": string(content)})
}, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "read_file",
        Description: "读取文件内容",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "文件路径"}
            },
            "required": ["path"]
        }`),
    },
})

// 写入文件
registry.Register("write_file", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Path    string `json:"path"`
        Content string `json:"content"`
    }
    json.Unmarshal(args, &params)
    
    err := os.WriteFile(params.Path, []byte(params.Content), 0644)
    if err != nil {
        return nil, err
    }
    
    return json.Marshal(map[string]bool{"success": true})
}, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "write_file",
        Description: "写入文件内容",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "path": {"type": "string"},
                "content": {"type": "string"}
            },
            "required": ["path", "content"]
        }`),
    },
})
```

### HTTP 请求

```go
registry.Register("http_request", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        URL     string            `json:"url"`
        Method  string            `json:"method"`
        Headers map[string]string `json:"headers"`
        Body    string            `json:"body"`
    }
    json.Unmarshal(args, &params)
    
    if params.Method == "" {
        params.Method = "GET"
    }
    
    req, _ := http.NewRequestWithContext(ctx, params.Method, params.URL, strings.NewReader(params.Body))
    for k, v := range params.Headers {
        req.Header.Set(k, v)
    }
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    return json.Marshal(map[string]interface{}{
        "status": resp.StatusCode,
        "body":   string(body),
    })
}, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "http_request",
        Description: "发送 HTTP 请求",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "url": {"type": "string"},
                "method": {"type": "string", "enum": ["GET", "POST", "PUT", "DELETE"]},
                "headers": {"type": "object"},
                "body": {"type": "string"}
            },
            "required": ["url"]
        }`),
    },
    Timeout: 30 * time.Second,
    RateLimit: &tools.RateLimitConfig{
        MaxCalls: 100,
        Window:   time.Minute,
    },
})
```

### 代码执行

```go
registry.Register("execute_code", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Language string `json:"language"`
        Code     string `json:"code"`
    }
    json.Unmarshal(args, &params)
    
    // 使用沙箱执行代码
    result, err := sandbox.Execute(ctx, params.Language, params.Code)
    if err != nil {
        return nil, err
    }
    
    return json.Marshal(result)
}, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "execute_code",
        Description: "在沙箱中执行代码",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "language": {"type": "string", "enum": ["python", "javascript", "go"]},
                "code": {"type": "string"}
            },
            "required": ["language", "code"]
        }`),
    },
    Timeout: 60 * time.Second,
})
```

## OpenAPI 工具生成

从 OpenAPI 规范自动生成工具：

```go
import "github.com/BaSui01/agentflow/tools/openapi"

// 从 OpenAPI 规范生成工具
generator := openapi.NewGenerator(openapi.Config{
    BaseURL: "https://api.example.com",
    Auth: &openapi.AuthConfig{
        Type:   "bearer",
        Token:  os.Getenv("API_TOKEN"),
    },
})

tools, err := generator.GenerateFromSpec("./openapi.yaml")
if err != nil {
    log.Fatal(err)
}

// 注册生成的工具
for _, tool := range tools {
    registry.Register(tool.Name, tool.Func, tool.Metadata)
}
```

## 最佳实践

1. **明确的工具描述**：LLM 依赖描述选择工具，描述要清晰准确
2. **参数验证**：在工具函数中验证参数，返回有意义的错误
3. **超时控制**：为每个工具设置合理的超时时间
4. **速率限制**：对外部 API 调用设置速率限制
5. **错误处理**：返回结构化的错误信息，便于 LLM 理解
6. **日志记录**：记录工具调用和结果，便于调试
7. **安全考虑**：敏感操作需要权限验证

## 高级特性

### 工具执行结果

```go
type ToolResult struct {
    ToolCallID string          `json:"tool_call_id"`    // 对应的 ToolCall ID
    Name       string          `json:"name"`            // 工具名称
    Result     json.RawMessage `json:"result"`          // 执行结果（JSON）
    Error      string          `json:"error,omitempty"` // 错误信息
    Duration   time.Duration   `json:"duration"`        // 执行耗时
}
```

### 工具元数据

```go
type ToolMetadata struct {
    Schema      llm.ToolSchema   // 工具的 JSON Schema
    Permission  string           // 所需权限（可选，用于鉴权）
    RateLimit   *RateLimitConfig // 速率限制配置（可选）
    Timeout     time.Duration    // 执行超时（默认 30s）
    Description string           // 详细描述
}
```

### 动态工具注册

```go
// 运行时动态注册工具
registry.Register("dynamic_tool", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    // 动态逻辑
    return json.Marshal(result)
}, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "dynamic_tool",
        Description: "动态注册的工具",
        Parameters:  json.RawMessage(`{"type": "object"}`),
    },
})

// 运行时注销工具
registry.Unregister("dynamic_tool")
```

### 工具权限控制

```go
// 带权限的工具注册
registry.Register("admin_tool", adminFunc, tools.ToolMetadata{
    Schema:     schema,
    Permission: "admin", // 需要 admin 权限
})

// 执行前检查权限
func (e *SecureExecutor) ExecuteOne(ctx context.Context, call llm.ToolCall) ToolResult {
    _, meta, _ := e.registry.Get(call.Name)
    
    if meta.Permission != "" {
        user := ctx.Value("user").(User)
        if !user.HasPermission(meta.Permission) {
            return ToolResult{
                Error: "permission denied",
            }
        }
    }
    
    return e.executor.ExecuteOne(ctx, call)
}
```

---

## 成本控制系统

AgentFlow 通过 `llm/tokenizer/` 包提供统一的 Token 计数能力，结合 Provider 的使用量追踪实现成本控制。

### Token 计数器

```go
import "github.com/BaSui01/agentflow/llm/tokenizer"

// 精确计数（OpenAI 模型）
tok, _ := tokenizer.NewTiktokenTokenizer("gpt-4o")
count, _ := tok.CountTokens("Hello, 你好世界！")

// 快速估算（任意模型，无需下载数据）
est := tokenizer.NewEstimatorTokenizer("deepseek-chat", 32768)
count, _ := est.CountTokens("你好世界 Hello World")

// 消息级计数（包含 role 标记等开销）
messages := []tokenizer.Message{
    {Role: "user", Content: "你好"},
    {Role: "assistant", Content: "你好！有什么可以帮你的？"},
}
total, _ := tok.CountMessages(messages)
```

### 全局注册与自动回退

```go
// 注册所有 OpenAI 模型的 tokenizer
tokenizer.RegisterOpenAITokenizers()

// 获取 tokenizer，未注册时自动回退到估算器
tok := tokenizer.GetTokenizerOrEstimator("unknown-model")
```

### 成本追踪

每次 LLM 调用的 `ChatResponse.Usage` 包含 Token 使用量：

```go
resp, _ := provider.Completion(ctx, req)
fmt.Printf("输入 Token: %d, 输出 Token: %d, 总计: %d\n",
    resp.Usage.PromptTokens, resp.Usage.CompletionTokens, resp.Usage.TotalTokens)
```

---

## Browser Automation 工具集成

`agent/browser/` 包提供浏览器自动化能力，可作为 Agent 工具使用。

### 核心组件

| 文件 | 职责 |
|------|------|
| `browser.go` | Browser 接口、BrowserSession、BrowserTool |
| `chromedp_driver.go` | 基于 chromedp 的浏览器驱动实现 |
| `browser_pool.go` | 浏览器实例连接池 |
| `vision_adapter.go` | 截图→LLM 视觉分析适配器 |
| `agentic_browser.go` | Agent 级浏览器封装 |

### 基本使用

```go
import "github.com/BaSui01/agentflow/agent/browser"

// 创建浏览器工具
tool := browser.NewBrowserTool(factory, browser.BrowserConfig{
    Headless:          true,
    Timeout:           30 * time.Second,
    ViewportWidth:     1920,
    ViewportHeight:    1080,
    ScreenshotOnError: true,
}, logger)
defer tool.CloseAll()

// 获取或创建会话
session, _ := tool.GetOrCreateSession("session-1")

// 导航
session.Navigate(ctx, "https://example.com")

// 点击元素
session.Click(ctx, "#submit-button")

// 输入文本
session.Type(ctx, "#search-input", "AgentFlow")

// 截图
result, _ := session.Screenshot(ctx)

// 提取内容
result, _ := session.Extract(ctx, ".main-content")
```

### 支持的操作

| Action | 说明 |
|--------|------|
| `navigate` | 导航到 URL |
| `click` | 点击元素 |
| `type` | 输入文本 |
| `scroll` | 滚动页面 |
| `screenshot` | 截图 |
| `extract` | 提取内容 |
| `wait` | 等待元素出现 |
| `select` | 选择下拉选项 |
| `hover` | 悬停 |
| `back` / `forward` / `refresh` | 浏览器导航 |
