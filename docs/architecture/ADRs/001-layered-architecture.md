# ADR 001: 分层架构设计

## 状态
- **状态**: 已接受
- **日期**: 2025-01-15
- **作者**: AgentFlow Team

## 背景

AgentFlow 是一个功能丰富的 LLM Agent 框架，需要支持多种 LLM 提供商、复杂的 Agent 推理模式、工作流编排、RAG 检索等功能。为了保持代码的可维护性和可扩展性，我们需要一个清晰的架构设计。

## 决策

我们采用**四层分层架构**:

```
┌─────────────────────────────────────────────────┐
│ Layer 3: Workflow (工作流编排)                    │
│  - DAG 工作流、Chain 工作流、并行执行              │
├─────────────────────────────────────────────────┤
│ Layer 2: Agent + RAG (核心能力层)                │
│  - Agent 框架、记忆系统、推理模式、护栏系统        │
│  - RAG 检索、向量存储、文档处理                   │
├─────────────────────────────────────────────────┤
│ Layer 1: LLM (Provider 抽象层)                   │
│  - Provider 接口、路由、缓存、弹性机制            │
│  - 13+ 提供商实现                               │
├─────────────────────────────────────────────────┤
│ Layer 0: Types (零依赖核心类型)                  │
│  - Message、Tool、Error 等核心类型              │
└─────────────────────────────────────────────────┘
```

### 依赖规则

1. **单向依赖**: 上层可以依赖下层，下层不能依赖上层
2. **同层依赖**: 同层模块之间可以依赖，但要避免循环依赖
3. **Types 包**: 零依赖，所有其他包都可以依赖它

## 后果

### 优点

- ✅ **清晰的职责分离**: 每层有明确的职责边界
- ✅ **可测试性**: 可以独立测试每层
- ✅ **可替换性**: 可以替换某层的实现而不影响其他层
- ✅ **避免循环依赖**: 严格的依赖方向避免循环依赖

### 缺点

- ❌ **更多的接口定义**: 需要定义清晰的接口
- ❌ **跨层调用开销**: 可能需要通过多层调用
- ❌ **学习成本**: 新开发者需要理解分层规则

## 替代方案

### 替代方案 1: 微内核架构
- **描述**: 核心提供基础功能，其他功能作为插件
- **拒绝原因**: 对于 Agent 框架来说过于复杂，插件管理成本高

### 替代方案 2: 六边形架构 (Ports & Adapters)
- **描述**: 以领域为核心，外部通过适配器接入
- **拒绝原因**: 对于当前规模过于复杂，分层架构更合适

## 相关决策

- ADR 002: Provider 接口设计
- ADR 003: Agent 状态管理

## 参考

- [Go 项目标准布局](https://github.com/golang-standards/project-layout)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
