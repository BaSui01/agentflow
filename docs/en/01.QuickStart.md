# AgentFlow Quick Start Guide

## Introduction

AgentFlow is a high-performance Go AI Agent framework providing unified LLM abstraction, intelligent routing, tool calling, and workflow orchestration.

## Installation

```bash
go get github.com/BaSui01/agentflow
```

## Core Concepts

### 1. Provider

Provider is the unified abstraction interface for LLM services, supporting OpenAI, Claude, Gemini, DeepSeek, and more.

```go
import (
    "github.com/BaSui01/agentflow/providers/openai"
    "github.com/BaSui01/agentflow/providers"
)

// Create OpenAI Provider
provider := openai.NewOpenAIProvider(providers.OpenAIConfig{
    APIKey:  os.Getenv("OPENAI_API_KEY"),
    BaseURL: "https://api.openai.com",
    Model:   "gpt-4",
}, logger)
```

### 2. Agent

Agent is the core execution unit, encapsulating state management, memory, and tool calling capabilities.

```go
import "github.com/BaSui01/agentflow/agent"

// Create Agent configuration
cfg := agent.Config{
    ID:          "my-agent",
    Name:        "Assistant",
    Type:        agent.TypeAssistant,
    Model:       "gpt-4",
    MaxTokens:   4096,
    Temperature: 0.7,
}

// Create Agent
myAgent := agent.NewBaseAgent(cfg, provider, memory, toolManager, eventBus, logger)

// Initialize
if err := myAgent.Init(ctx); err != nil {
    log.Fatal(err)
}

// Execute task
output, err := myAgent.Execute(ctx, &agent.Input{
    TraceID: "trace-001",
    Content: "Please analyze this code",
})
```

### 3. Tool Calling

The framework supports native tool calling with automatic ReAct loop handling LLM → Tool → LLM conversations.

```go
import "github.com/BaSui01/agentflow/llm/tools"

// Register tool
registry := tools.NewDefaultRegistry(logger)
registry.Register("search", searchFunc, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "search",
        Description: "Search for information",
        Parameters:  json.RawMessage(`{"type":"object","properties":{"query":{"type":"string"}}}`),
    },
    Timeout: 30 * time.Second,
})

// Create executor
executor := tools.NewDefaultExecutor(registry, logger)

// ReAct loop handles tool calls automatically
reactExecutor := tools.NewReActExecutor(provider, executor, tools.ReActConfig{
    MaxIterations: 10,
    StopOnError:   false,
}, logger)
```

## Data Flow Architecture

```
User Input → Agent.Execute()
    ↓
Input Validation (Guardrails)
    ↓
Build Messages (System Prompt + Context + User Input)
    ↓
LLM Call (Provider.Completion/Stream)
    ↓
[If Tool Calls] → ReAct Loop
    ↓                   ↓
    ↓              Tool Execution
    ↓                   ↓
    ↓              Return Results to LLM
    ↓                   ↓
    ←←←←←←←←←←←←←←←←←←←
    ↓
Output Validation (Guardrails)
    ↓
Save Memory
    ↓
Return Result
```

## Resilience Features

### Retry Mechanism

```go
import "github.com/BaSui01/agentflow/llm/retry"

policy := &retry.RetryPolicy{
    MaxRetries:   3,
    InitialDelay: 1 * time.Second,
    MaxDelay:     30 * time.Second,
    Multiplier:   2.0,
    Jitter:       true, // Prevent thundering herd
}

retryer := retry.NewBackoffRetryer(policy, logger)
```

### Circuit Breaker

```go
import "github.com/BaSui01/agentflow/llm/circuitbreaker"

breaker := circuitbreaker.NewCircuitBreaker(&circuitbreaker.Config{
    Threshold:        5,  // Trip after 5 consecutive failures
    ResetTimeout:     60 * time.Second,
    HalfOpenMaxCalls: 3,
}, logger)
```

### Resilient Provider

```go
import "github.com/BaSui01/agentflow/llm"

resilientProvider := llm.NewResilientProviderSimple(
    provider,
    idempotencyManager,
    logger,
)
```

## Next Steps

- [02.Provider Configuration](02.ProviderConfiguration.md)
- [03.Agent Development](03.AgentDevelopment.md)
- [04.Tool Integration](04.ToolIntegration.md)
- [05.Workflow Orchestration](05.WorkflowOrchestration.md)
