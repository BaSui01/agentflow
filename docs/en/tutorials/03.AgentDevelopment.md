# Agent Development Tutorial

AgentFlow provides a complete agent development framework with state management, multi-layer memory, skills system, MCP integration, guardrails, advanced reasoning patterns, Human-in-the-Loop, async execution, voice interaction, and sandbox execution.

## Creating Agents

### Using the Builder Pattern

```go
import (
    "github.com/BaSui01/agentflow/agent"
    "github.com/BaSui01/agentflow/llm/providers/openai"
)

provider := openai.NewOpenAIProvider(cfg, logger)

myAgent, err := agent.NewAgentBuilder(agent.Config{
    ID:           "assistant-001",
    Name:         "Smart Assistant",
    Type:         agent.TypeAssistant,
    Model:        "gpt-4o",
    MaxTokens:    4096,
    Temperature:  0.7,
    PromptBundle: agent.PromptBundle{
        Version: "1.0.0",
        System: agent.SystemPrompt{
            Identity:    "You are a professional technical assistant",
            Policies:    []string{"Be professional", "Provide accurate information"},
            OutputRules: []string{"Use clear language"},
            Prohibits:   []string{"Do not disclose sensitive information"},
        },
        Constraints: []string{"Keep answers concise"},
    },
    Tools: []string{"search", "calculator", "code_executor"},
    EnableReflection:     true,
    EnableToolSelection:  true,
    EnablePromptEnhancer: true,
}).
    WithProvider(provider).
    WithLogger(logger).
    WithReflection(nil).
    WithToolSelection(nil).
    Build()
```

### Agent Types

```go
const (
    TypeGeneric    AgentType = "generic"
    TypeAssistant  AgentType = "assistant"
    TypeAnalyzer   AgentType = "analyzer"
    TypeTranslator AgentType = "translator"
    TypeSummarizer AgentType = "summarizer"
    TypeReviewer   AgentType = "reviewer"
)
```

### Agent Lifecycle

```go
// Create lifecycle manager
lifecycle := agent.NewLifecycleManager(myAgent, logger)

// Start (includes initialization and health checks)
if err := lifecycle.Start(ctx); err != nil {
    log.Fatal(err)
}

// Check running status
if lifecycle.IsRunning() {
    health := lifecycle.GetHealthStatus()
    fmt.Printf("Healthy: %v, State: %s\n", health.Healthy, health.State)
}

// Execute task
response, err := myAgent.Execute(ctx, &agent.Input{
    TraceID: "trace-001",
    Content: "Analyze this code",
    Variables: map[string]string{"language": "Go"},
})

// Restart
lifecycle.Restart(ctx)

// Stop
lifecycle.Stop(ctx)
```

### State Machine

```
Init → Ready → Running → Ready → Stopped
         ↑       ↓
         └───────┘
```

```go
const (
    StateInit     State = "init"
    StateReady    State = "ready"
    StateRunning  State = "running"
    StateStopped  State = "stopped"
    StateError    State = "error"
)

state := myAgent.State()
if state == agent.StateReady {
    // Can execute tasks
}
```

## Modular Prompt System (PromptBundle)

### PromptBundle Structure

```go
type PromptBundle struct {
    Version     string
    System      SystemPrompt
    Tools       []llm.ToolSchema
    Examples    []Example         // Few-shot examples
    Memory      MemoryConfig
    Plan        *PlanConfig
    Reflection  *ReflectionConfig
    Constraints []string
}
```

### Template Variable Substitution

```go
bundle := agent.PromptBundle{
    Version: "1.0.0",
    System: agent.SystemPrompt{
        Identity: "You are {{company}}'s {{role}}",
        Policies: []string{"Respond in {{language}}"},
    },
}

// Extract all variables
vars := bundle.ExtractVariables() // ["company", "role", "language"]

// Render with variables
prompt := bundle.RenderSystemPromptWithVars(map[string]string{
    "company":  "AgentFlow",
    "role":     "technical assistant",
    "language": "English",
})
```

### Prompt Enhancer

```go
enhancer := agent.NewPromptEnhancer(agent.PromptEngineeringConfig{
    UseChainOfThought:   true,
    UseStructuredOutput: true,
    UseFewShot:          true,
    MaxExamples:         3,
    UseDelimiters:       true,
})

enhancedBundle := enhancer.EnhancePromptBundle(bundle)
```

## Defensive Prompt Engineering

```go
defensive := agent.NewDefensivePromptEnhancer(agent.DefensivePromptConfig{
    FailureModes: []agent.FailureMode{
        {Condition: "missing_data", Action: "return_error"},
        {Condition: "ambiguous_input", Action: "request_clarification"},
    },
    OutputSchema: &agent.OutputSchema{
        Type:     "json",
        Required: []string{"answer", "confidence"},
    },
    GuardRails: []agent.GuardRail{
        {Type: "never", Category: "data_safety", Description: "Never modify user data", Severity: "critical"},
    },
    InjectionDefense: &agent.InjectionDefenseConfig{
        Enabled:       true,
        UseDelimiters: true,
        SanitizeInput: true,
        RoleIsolation: true,
    },
})

safeBundle := defensive.EnhancePromptBundle(bundle)
safeInput, ok := defensive.SanitizeUserInput(userInput)
```

## Multi-Layer Memory System

### Enhanced Memory System

Five memory types: short-term, working, long-term, episodic, and semantic.

```go
import "github.com/BaSui01/agentflow/agent/memory"

memorySystem := memory.NewEnhancedMemorySystem(
    shortTermStore, workingStore, vectorStore, episodicStore, knowledgeGraph,
    memory.EnhancedMemoryConfig{
        ShortTermTTL:         24 * time.Hour,
        WorkingMemorySize:    20,
        LongTermEnabled:      true,
        EpisodicEnabled:      true,
        SemanticEnabled:      true,
        ConsolidationEnabled: true,
    },
    logger,
)

memorySystem.SaveShortTerm(ctx, agentID, content, metadata)
results, _ := memorySystem.SearchLongTerm(ctx, agentID, queryVector, topK)
memorySystem.RecordEpisode(ctx, &memory.EpisodicEvent{...})
memorySystem.AddKnowledge(ctx, &memory.Entity{...})
```

### Layered Memory

```go
layeredMemory := memory.NewLayeredMemory(config, logger)

layeredMemory.Episodic.Store(&memory.Episode{...})
layeredMemory.Semantic.StoreFact(ctx, &memory.Fact{...})
layeredMemory.Working.Set("key", value, priority)
layeredMemory.Procedural.Store(&memory.Procedure{...})
```

## Skills System

```go
import "github.com/BaSui01/agentflow/agent/skills"

skill, _ := skills.NewSkillBuilder("code_review", "Code Review").
    WithDescription("Review code quality and best practices").
    WithCategory("development").
    WithInstructions("You are a code review expert...").
    WithTools("read_file", "search_code").
    Build()

manager := skills.NewSkillManager(config, logger)
manager.RegisterSkill(skill)
matchedSkills, _ := manager.DiscoverSkills(ctx, "review this Go code")
```

## MCP Integration

```go
import "github.com/BaSui01/agentflow/agent/mcp"

client := mcp.NewMCPClient(reader, writer, logger)
client.Connect(ctx, "mcp://localhost:8080")

tools, _ := client.ListTools(ctx)
result, _ := client.CallTool(ctx, "search", args)
```

## Guardrails

```go
import "github.com/BaSui01/agentflow/agent/guardrails"

chain := guardrails.NewValidatorChain(logger)
chain.Add(guardrails.NewLengthValidator(10000))
chain.Add(guardrails.NewPIIDetector(config))
chain.Add(guardrails.NewInjectionDetector(config))

result, _ := chain.Validate(ctx, userInput)
```

## Advanced Reasoning Patterns

### Tree of Thought (ToT)

```go
import "github.com/BaSui01/agentflow/agent/reasoning"

tot := reasoning.NewTreeOfThought(provider, executor, reasoning.TreeOfThoughtConfig{
    BranchingFactor: 3,
    MaxDepth:        5,
    BeamWidth:       2,
    PruneThreshold:  0.3,
    ParallelEval:    true,
}, logger)

result, _ := tot.Execute(ctx, "Design a high-concurrency message queue")
```

### ReWOO (Reasoning Without Observation)

```go
rewoo := reasoning.NewReWOO(provider, toolExecutor, toolSchemas, reasoning.ReWOOConfig{
    MaxPlanSteps:    10,
    Timeout:         120 * time.Second,
    ParallelWorkers: 5,
}, logger)

result, _ := rewoo.Execute(ctx, "Collect and analyze sales data")
```

### Reflexion (Self-Improving)

```go
reflexion := reasoning.NewReflexionExecutor(provider, toolExecutor, toolSchemas, reasoning.ReflexionConfig{
    MaxTrials:        5,
    SuccessThreshold: 0.8,
    EnableMemory:     true,
}, logger)

result, _ := reflexion.Execute(ctx, "Write an efficient sorting algorithm")
```

### Plan-and-Execute

```go
planExec := reasoning.NewPlanAndExecute(provider, toolExecutor, toolSchemas, reasoning.PlanExecuteConfig{
    MaxPlanSteps:      15,
    MaxReplanAttempts: 3,
    AdaptivePlanning:  true,
}, logger)

result, _ := planExec.Execute(ctx, "Deploy a microservice application")
```

### Dynamic Planner (with Backtracking)

```go
planner := reasoning.NewDynamicPlanner(provider, toolExecutor, toolSchemas, reasoning.DynamicPlannerConfig{
    MaxBacktracks:       5,
    MaxPlanDepth:        20,
    ConfidenceThreshold: 0.4,
    EnableParallel:      true,
}, logger)

result, _ := planner.Execute(ctx, "Solve complex optimization problem")
```

## Human-in-the-Loop

### Approval Manager

```go
store := agent.NewInMemoryApprovalStore()
hitlManager := agent.NewHumanInLoopManager(store, eventBus, logger)

response, err := hitlManager.RequestApproval(ctx,
    agentID,
    agent.ApprovalTypeToolCall,
    "Agent requests to execute delete operation",
    5 * time.Minute,
)

if response.Approved {
    // Execute operation
}
```

### Approval Types

```go
const (
    ApprovalTypeToolCall    ApprovalType = "tool_call"
    ApprovalTypeOutput      ApprovalType = "output"
    ApprovalTypeStateChange ApprovalType = "state_change"
    ApprovalTypeDataAccess  ApprovalType = "data_access"
    ApprovalTypeCustom      ApprovalType = "custom"
)
```

### Workflow Interrupt Manager

```go
import "github.com/BaSui01/agentflow/agent/hitl"

interruptManager := hitl.NewInterruptManager(store, logger)

response, err := interruptManager.CreateInterrupt(ctx, hitl.InterruptOptions{
    WorkflowID:  "workflow-001",
    NodeID:      "step-3",
    Type:        hitl.InterruptTypeApproval,
    Title:       "Approval Required",
    Options:     []hitl.Option{{ID: "approve", Label: "Approve"}, {ID: "reject", Label: "Reject"}},
    Timeout:     10 * time.Minute,
})

interruptManager.ResolveInterrupt(ctx, interruptID, &hitl.Response{Approved: true})
```

## Async Execution & Subagents

### Async Executor

```go
asyncExecutor := agent.NewAsyncExecutor(myAgent, logger)

execution, _ := asyncExecutor.ExecuteAsync(ctx, &agent.Input{
    TraceID: "async-001",
    Content: "Execute long-running task",
})

output, err := execution.Wait(ctx)
```

### Parallel Subagent Execution

```go
subagents := []agent.Agent{analyzerAgent, summarizerAgent, reviewerAgent}
output, err := asyncExecutor.ExecuteWithSubagents(ctx, input, subagents)
```

### Realtime Coordinator

```go
manager := agent.NewSubagentManager(logger)
coordinator := agent.NewRealtimeCoordinator(manager, eventBus, logger)
output, err := coordinator.CoordinateSubagents(ctx, subagents, input)
```

## Voice Interaction

### Realtime Voice Agent

```go
import "github.com/BaSui01/agentflow/agent/voice"

voiceAgent := voice.NewVoiceAgent(voice.VoiceConfig{
    STTProvider:      "deepgram",
    TTSProvider:      "elevenlabs",
    SampleRate:       16000,
    MaxLatencyMS:     300,
    VADEnabled:       true,
    InterruptEnabled: true,
}, sttProvider, ttsProvider, llmHandler, logger)

session, _ := voiceAgent.Start(ctx)
session.SendAudio(audioChunk)

for speech := range session.ReceiveSpeech() {
    playAudio(speech.Audio)
}

session.Interrupt()
session.Close()
```

### Native Multimodal Audio (GPT-4o Style)

```go
reasoner := voice.NewNativeAudioReasoner(audioProvider, voice.NativeAudioConfig{
    TargetLatencyMS: 232,
    SampleRate:      24000,
    EnableVAD:       true,
}, logger)

output, _ := reasoner.Process(ctx, voice.MultimodalInput{Audio: audioFrames})
fmt.Printf("Latency: %dms, Target Hit Rate: %.2f%%\n", output.LatencyMS, reasoner.GetMetrics().TargetHitRate * 100)

// Streaming for lowest latency
outputChan, _ := reasoner.StreamProcess(ctx, inputChan)
```

## Sandbox Code Execution

```go
import "github.com/BaSui01/agentflow/agent/sandbox"

backend := sandbox.NewDockerBackend(logger)
executor := sandbox.NewSandboxExecutor(sandbox.SandboxConfig{
    Mode:             sandbox.ModeDocker,
    Timeout:          30 * time.Second,
    MaxMemoryMB:      512,
    NetworkEnabled:   false,
    AllowedLanguages: []sandbox.Language{sandbox.LangPython, sandbox.LangJavaScript},
}, backend, logger)

result, _ := executor.Execute(ctx, &sandbox.ExecutionRequest{
    Language: sandbox.LangPython,
    Code:     "print('Hello, World!')",
})

// Code validation
validator := sandbox.NewCodeValidator()
warnings := validator.Validate(sandbox.LangPython, code)
```

## Hierarchical Agent

Supervisor-Worker pattern for hierarchical agent systems.

### Creating Hierarchical Agent

```go
import "github.com/BaSui01/agentflow/agent/hierarchical"

hierarchicalAgent := hierarchical.NewHierarchicalAgent(hierarchical.HierarchicalConfig{
    MaxWorkers:       10,
    TaskTimeout:      5 * time.Minute,
    RetryAttempts:    3,
    LoadBalancing:    hierarchical.LoadBalanceRoundRobin,
    EnableMonitoring: true,
}, provider, logger)

// Register worker agents
hierarchicalAgent.RegisterWorker("analyzer", analyzerAgent)
hierarchicalAgent.RegisterWorker("summarizer", summarizerAgent)

// Execute task (auto-assigned to appropriate worker)
result, _ := hierarchicalAgent.Execute(ctx, &hierarchical.Task{
    ID:          "task-001",
    Type:        "analysis",
    Description: "Analyze code quality",
    Priority:    hierarchical.PriorityHigh,
})
```

### Task Coordinator

```go
coordinator := hierarchical.NewTaskCoordinator(hierarchical.CoordinatorConfig{
    MaxConcurrent:    5,
    QueueSize:        100,
    SchedulingPolicy: hierarchical.SchedulePriority,
    EnablePreemption: true,
}, logger)

taskID, _ := coordinator.Submit(ctx, &hierarchical.Task{...})
result, _ := coordinator.Wait(ctx, taskID)
coordinator.Cancel(ctx, taskID)

status := coordinator.GetQueueStatus()
```

### Load Balancing Strategies

```go
const (
    LoadBalanceRoundRobin LoadBalanceStrategy = "round_robin"
    LoadBalanceLeastBusy  LoadBalanceStrategy = "least_busy"
    LoadBalanceWeighted   LoadBalanceStrategy = "weighted"
    LoadBalanceCapability LoadBalanceStrategy = "capability"
)
```

## Multi-Agent Collaboration

Multiple collaboration patterns for multi-agent systems.

### Collaboration Modes

```go
import "github.com/BaSui01/agentflow/agent/collaboration"

multiAgent := collaboration.NewMultiAgentCoordinator(collaboration.MultiAgentConfig{
    MaxAgents:        10,
    CommunicationTTL: 5 * time.Minute,
}, logger)

multiAgent.RegisterAgent("analyst", analystAgent)
multiAgent.RegisterAgent("critic", criticAgent)
```

### Debate Mode

Multiple agents debate to reach the best answer:

```go
result, _ := multiAgent.Debate(ctx, collaboration.DebateConfig{
    Topic:      "Best microservice architecture",
    Rounds:     3,
    Moderator:  "synthesizer",
    Debaters:   []string{"analyst", "critic"},
    VotingMode: collaboration.VoteMajority,
})
```

### Consensus Mode

All agents reach consensus:

```go
result, _ := multiAgent.Consensus(ctx, collaboration.ConsensusConfig{
    Question:  "Which database should we use?",
    Agents:    []string{"analyst", "critic", "synthesizer"},
    Threshold: 0.8,
    MaxRounds: 5,
})

if result.ConsensusReached {
    fmt.Printf("Consensus: %s\n", result.Decision)
}
```

### Pipeline Mode

Sequential agent processing:

```go
result, _ := multiAgent.Pipeline(ctx, collaboration.PipelineConfig{
    Input: "Raw requirements document",
    Stages: []collaboration.Stage{
        {Agent: "analyst", Task: "Analyze requirements"},
        {Agent: "designer", Task: "Design solution"},
        {Agent: "reviewer", Task: "Review solution"},
    },
})
```

### Broadcast Mode

Send task to all agents simultaneously:

```go
results, _ := multiAgent.Broadcast(ctx, collaboration.BroadcastConfig{
    Message: "Evaluate this technical proposal",
    Agents:  []string{"analyst", "critic", "security_expert"},
    WaitAll: true,
})
```

### Network Mode

Free communication between agents:

```go
network := multiAgent.CreateNetwork(ctx, collaboration.NetworkConfig{
    Agents:   []string{"a", "b", "c"},
    Topology: collaboration.TopologyMesh,
})

network.Send("a", "b", "Need your help analyzing this")
network.OnMessage("b", func(from, msg string) {
    fmt.Printf("Message from %s: %s\n", from, msg)
})
```

## Federation Orchestrator

Cross-organization agent collaboration.

```go
import "github.com/BaSui01/agentflow/agent/federation"

orchestrator := federation.NewFederationOrchestrator(federation.FederationConfig{
    NodeID:            "org-001",
    DiscoveryService:  "consul://localhost:8500",
    AuthProvider:      authProvider,
    HeartbeatInterval: 30 * time.Second,
}, logger)

orchestrator.Start(ctx)

// Discover peers
peers, _ := orchestrator.DiscoverPeers(ctx)

// Cross-organization delegation
result, _ := orchestrator.Delegate(ctx, &federation.DelegationRequest{
    TargetOrg: "org-002",
    AgentType: "specialist",
    Task:      "Perform specialized analysis",
})

// Register local agent for external access
orchestrator.RegisterLocalAgent("analyst", analystAgent, federation.AccessPolicy{
    AllowedOrgs: []string{"org-002"},
    RateLimit:   100,
    RequireAuth: true,
})
```

## Crews (CrewAI-Style Teams)

Role-based agent team collaboration.

```go
import "github.com/BaSui01/agentflow/agent/crews"

crew := crews.NewCrew(crews.CrewConfig{
    Name:    "Development Team",
    Process: crews.ProcessSequential,
}, logger)

// Define roles
crew.AddAgent(&crews.CrewAgent{
    Role:      "Product Manager",
    Goal:      "Define product requirements",
    Backstory: "Experienced PM who understands user needs",
    Agent:     pmAgent,
})

crew.AddAgent(&crews.CrewAgent{
    Role:      "Architect",
    Goal:      "Design system architecture",
    Backstory: "Senior architect skilled in distributed systems",
    Agent:     architectAgent,
})

crew.AddAgent(&crews.CrewAgent{
    Role:      "Developer",
    Goal:      "Implement features",
    Backstory: "Full-stack developer with high code quality",
    Agent:     devAgent,
})

// Define tasks
crew.AddTask(&crews.Task{
    Description:    "Analyze user feedback, extract requirements",
    ExpectedOutput: "Requirements document",
    Agent:          "Product Manager",
})

crew.AddTask(&crews.Task{
    Description:    "Design technical solution",
    ExpectedOutput: "Architecture document",
    Agent:          "Architect",
    Context:        []string{"Requirements document"},
})

// Execute crew
result, _ := crew.Kickoff(ctx, "Build a user authentication module")
```

### Crew Process Modes

```go
const (
    ProcessSequential   CrewProcess = "sequential"
    ProcessHierarchical CrewProcess = "hierarchical"
    ProcessConsensus    CrewProcess = "consensus"
)
```

## Intelligent Memory Decay

Smart memory management based on importance and access patterns.

```go
import "github.com/BaSui01/agentflow/agent/memory"

decayManager := memory.NewIntelligentDecay(memory.DecayConfig{
    BaseDecayRate:          0.1,
    ImportanceWeight:       0.5,
    RecencyWeight:          0.3,
    FrequencyWeight:        0.2,
    MinRetention:           0.1,
    DecayInterval:          1 * time.Hour,
    ConsolidationThreshold: 0.7,
}, logger)

decayManager.Start(ctx)

// Add memory with importance score
decayManager.AddMemory(&memory.DecayableMemory{
    ID:         "mem-001",
    Content:    "User prefers concise answers",
    Importance: 0.8,
})

// Access memory (updates statistics)
mem, _ := decayManager.Access(ctx, "mem-001")

// Get retention score
score := decayManager.GetRetentionScore("mem-001")

// Trigger decay
decayManager.Decay(ctx)

// Consolidate similar memories
decayManager.Consolidate(ctx)
```

### Decay Strategies

```go
const (
    DecayLinear      DecayStrategy = "linear"
    DecayExponential DecayStrategy = "exponential"
    DecayStepwise    DecayStrategy = "stepwise"
    DecayAdaptive    DecayStrategy = "adaptive"
)
```

## Artifact Manager

Google ADK-style artifact lifecycle management.

```go
import "github.com/BaSui01/agentflow/agent/artifacts"

store, _ := artifacts.NewFileStore("./artifacts")

manager := artifacts.NewManager(artifacts.ManagerConfig{
    BasePath:   "./artifacts",
    MaxSize:    100 * 1024 * 1024,
    DefaultTTL: 24 * time.Hour,
}, store, logger)

// Create artifact
artifact, _ := manager.Create(ctx, "result.json", artifacts.ArtifactTypeData, dataReader,
    artifacts.WithMimeType("application/json"),
    artifacts.WithTags("analysis", "report"),
    artifacts.WithSessionID(sessionID),
    artifacts.WithTTL(7 * 24 * time.Hour),
)

// Get artifact
artifact, reader, _ := manager.Get(ctx, artifactID)

// List artifacts
artifacts, _ := manager.List(ctx, artifacts.ArtifactQuery{
    SessionID: sessionID,
    Type:      artifacts.ArtifactTypeData,
})

// Create new version
newVersion, _ := manager.CreateVersion(ctx, artifact.ID, newDataReader)

// Cleanup expired
deleted, _ := manager.Cleanup(ctx)
```

### Artifact Types

```go
const (
    ArtifactTypeFile   ArtifactType = "file"
    ArtifactTypeData   ArtifactType = "data"
    ArtifactTypeImage  ArtifactType = "image"
    ArtifactTypeCode   ArtifactType = "code"
    ArtifactTypeOutput ArtifactType = "output"
    ArtifactTypeModel  ArtifactType = "model"
)
```

## Agentic Browser (Vision-Action Loop)

Vision model-based browser automation.

```go
import "github.com/BaSui01/agentflow/agent/browser"

agenticBrowser := browser.NewAgenticBrowser(
    browserDriver,
    visionModel,
    browser.AgenticBrowserConfig{
        MaxActions:      50,
        ActionDelay:     500 * time.Millisecond,
        Timeout:         5 * time.Minute,
        RetryOnFailure:  true,
    },
    logger,
)

result, _ := agenticBrowser.ExecuteTask(ctx, browser.BrowserTask{
    ID:       "task-001",
    Goal:     "Search for AgentFlow on GitHub and get star count",
    StartURL: "https://github.com",
})

fmt.Printf("Success: %v, Actions: %d, Duration: %v\n", 
    result.Success, len(result.Actions), result.Duration)
```

### Vision-Action Loop Flow

```
1. Screenshot → 2. Vision Analysis → 3. Check Goal → 4. Plan Actions → 5. Execute → Repeat
```

## LSP Integration

Language Server Protocol client for code intelligence.

```go
import "github.com/BaSui01/agentflow/agent/lsp"

client := lsp.NewLSPClient(reader, writer, logger)

result, _ := client.Initialize(ctx, lsp.InitializeParams{
    ProcessID: os.Getpid(),
    RootURI:   "file:///path/to/project",
})

// Code completion
completions, _ := client.TextDocumentCompletion(ctx, lsp.CompletionParams{
    TextDocument: lsp.TextDocumentIdentifier{URI: "file:///main.go"},
    Position:     lsp.Position{Line: 10, Character: 5},
})

// Hover info
hover, _ := client.TextDocumentHover(ctx, params)

// Go to definition
locations, _ := client.TextDocumentDefinition(ctx, params)

// Find references
refs, _ := client.TextDocumentReferences(ctx, params)

// Document symbols
symbols, _ := client.TextDocumentDocumentSymbol(ctx, params)

// Code actions
actions, _ := client.TextDocumentCodeAction(ctx, params)

client.Shutdown(ctx)
```

## Long-Running Executor

Days-level task execution with checkpoints and recovery.

```go
import "github.com/BaSui01/agentflow/agent/longrunning"

executor := longrunning.NewExecutor(longrunning.ExecutorConfig{
    CheckpointInterval: 5 * time.Minute,
    CheckpointDir:      "./checkpoints",
    MaxRetries:         3,
    AutoResume:         true,
}, logger)

steps := []longrunning.StepFunc{
    func(ctx context.Context, state any) (any, error) { return collectData(ctx, state) },
    func(ctx context.Context, state any) (any, error) { return processData(ctx, state) },
    func(ctx context.Context, state any) (any, error) { return generateReport(ctx, state) },
}

exec := executor.CreateExecution("Data Analysis", steps)
executor.Start(ctx, exec.ID, initialState)

// Check progress
exec, _ := executor.GetExecution(exec.ID)
fmt.Printf("Progress: %.2f%%, Step: %d/%d\n", exec.Progress, exec.CurrentStep, exec.TotalSteps)

// Pause/Resume
executor.Pause(exec.ID)
executor.Resume(exec.ID)

// Load from checkpoint
exec, _ = executor.LoadExecution(exec.ID)
```

## Kubernetes Operator

Kubernetes-native agent management with auto-scaling and self-healing.

```go
import "github.com/BaSui01/agentflow/agent/k8s"

operator := k8s.NewAgentOperator(k8s.OperatorConfig{
    Namespace:         "agents",
    ReconcileInterval: 30 * time.Second,
    LeaderElection:    true,
}, logger)

operator.SetReconcileCallback(func(agent *k8s.AgentCRD) error { return nil })
operator.SetScaleCallback(func(agent *k8s.AgentCRD, replicas int32) error { return nil })

operator.Start(ctx)

operator.RegisterAgent(&k8s.AgentCRD{
    APIVersion: "agentflow.io/v1",
    Kind:       "Agent",
    Metadata: k8s.ObjectMeta{
        Name:      "assistant",
        Namespace: "agents",
    },
    Spec: k8s.AgentSpec{
        AgentType: "assistant",
        Replicas:  3,
        Model:     k8s.ModelSpec{Provider: "openai", Model: "gpt-4o"},
        Scaling: k8s.ScalingSpec{
            Enabled:     true,
            MinReplicas: 1,
            MaxReplicas: 10,
            TargetMetrics: []k8s.TargetMetric{
                {Type: "requests_per_second", TargetValue: 100},
            },
        },
        HealthCheck: k8s.HealthCheckSpec{
            Enabled:          true,
            Interval:         10 * time.Second,
            FailureThreshold: 3,
        },
    },
})

agent := operator.GetAgent("agents", "assistant")
fmt.Printf("Phase: %s, Replicas: %d/%d\n", 
    agent.Status.Phase, agent.Status.ReadyReplicas, agent.Spec.Replicas)

operator.Stop()
```

## Observability System

Complete metrics collection, tracing, and evaluation.

```go
import "github.com/BaSui01/agentflow/agent/observability"

obsSystem := observability.NewObservabilitySystem(logger)

// Record task metrics
obsSystem.metricsCollector.RecordTask(agentID, true, 500*time.Millisecond, 1000, 0.05, 0.85)

// Get metrics
metrics := obsSystem.metricsCollector.GetMetrics(agentID)
fmt.Printf("Success Rate: %.2f%%, Avg Latency: %v, P95: %v\n", 
    metrics.TaskSuccessRate*100, metrics.AvgLatency, metrics.P95Latency)

// Start trace
trace := obsSystem.tracer.StartTrace(traceID, agentID)
obsSystem.tracer.AddSpan(traceID, &observability.Span{Name: "tool_execution"})
obsSystem.tracer.EndTrace(traceID, "completed", nil)

// Run benchmark
result, _ := obsSystem.evaluator.RunBenchmark(ctx, "qa_benchmark", myAgent)
```

## Decision Explainability

Track and explain agent decision processes.

```go
import "github.com/BaSui01/agentflow/agent/observability"

tracker := observability.NewExplainabilityTracker(observability.ExplainabilityConfig{
    Enabled:            true,
    DetailLevel:        "verbose",
    RecordAlternatives: true,
    RecordFactors:      true,
})

trace := tracker.StartTrace(sessionID, agentID)

tracker.AddStep(trace.ID, observability.ReasoningStep{
    Type:    "thought",
    Content: "User asks about code optimization, need to analyze code structure",
})

tracker.RecordDecision(trace.ID, observability.Decision{
    Type:        observability.DecisionToolSelection,
    Description: "Selected code analyzer tool",
    Reasoning:   "Task involves code analysis, code_analyzer is most suitable",
    Confidence:  0.9,
    Factors: []observability.Factor{
        {Name: "task_relevance", Value: 0.95, Weight: 0.5, Impact: "positive"},
    },
    Alternatives: []observability.Alternative{
        {Option: "code_analyzer", Score: 0.9, WasChosen: true},
        {Option: "search", Score: 0.6, WasChosen: false},
    },
})

tracker.EndTrace(trace.ID, true, "Analysis complete", "")

explanation := tracker.ExplainDecision(decision)
report, _ := tracker.GenerateAuditReport(trace.ID)
```

## Agent Registry

Centralized agent type and factory management.

```go
import "github.com/BaSui01/agentflow/agent"

agent.InitGlobalRegistry(logger)

// Register custom agent type
agent.RegisterAgentType("custom_analyzer", func(
    config agent.Config,
    provider llm.Provider,
    memory agent.MemoryManager,
    toolManager agent.ToolManager,
    bus agent.EventBus,
    logger *zap.Logger,
) (agent.Agent, error) {
    return agent.NewBaseAgent(config, provider, memory, toolManager, bus, logger), nil
})

// Create agent using registry
myAgent, _ := agent.CreateAgent(config, provider, memory, toolManager, bus, logger)

// Check if type is registered
if agent.GlobalRegistry.IsRegistered("custom_analyzer") {
    fmt.Println("Type registered")
}

// List all registered types
types := agent.GlobalRegistry.ListTypes()
```

## Deployment System

Deploy agents to multiple targets.

```go
import "github.com/BaSui01/agentflow/agent/deployment"

deployer := deployment.NewDeployer(deployment.DeployerConfig{
    Registry:     "docker.io/myorg",
    BuildTimeout: 10 * time.Minute,
}, logger)

// Build agent image
image, _ := deployer.BuildImage(ctx, &deployment.BuildConfig{
    AgentID:   "assistant-001",
    BaseImage: "golang:1.24-alpine",
    Tags:      []string{"v1.0.0", "latest"},
})

// Deploy to Kubernetes
deployer.DeployToK8s(ctx, &deployment.K8sDeployConfig{
    Namespace: "agents",
    Replicas:  3,
    Image:     image,
    Resources: deployment.Resources{
        CPULimit:    "500m",
        MemoryLimit: "512Mi",
    },
    HealthCheck: &deployment.HealthCheck{
        Path: "/health",
        Port: 8080,
    },
})

// Deploy to Cloud Run
deployer.DeployToCloudRun(ctx, &deployment.CloudRunConfig{
    Project:      "my-project",
    Region:       "us-central1",
    ServiceName:  "agent-assistant",
    MaxInstances: 10,
})

// Deploy to AWS Lambda
deployer.DeployToLambda(ctx, &deployment.LambdaConfig{
    FunctionName: "agent-assistant",
    Runtime:      "provided.al2",
    MemorySize:   512,
})
```

## Event System

```go
bus := agent.NewEventBus()

const (
    EventStateChange       EventType = "state_change"
    EventToolCall          EventType = "tool_call"
    EventApprovalRequested EventType = "approval_requested"
    EventSubagentCompleted EventType = "subagent_completed"
)

bus.Subscribe(agent.EventStateChange, func(event agent.Event) {
    e := event.(*agent.StateChangeEvent)
    log.Printf("Agent %s: %s → %s", e.AgentID_, e.FromState, e.ToState)
})

subscriptionID := bus.Subscribe(agent.EventToolCall, handler)
bus.Unsubscribe(subscriptionID)
```

## Best Practices

1. **Use Builder Pattern**: Clear configuration of agent features
2. **Enable Guardrails**: Required for production environments
3. **Configure Memory Appropriately**: Choose memory types based on use case
4. **Modularize Skills**: Split complex capabilities into independent skills
5. **Monitor Events**: Subscribe to key events for debugging
6. **Enable Checkpoints**: Protect long-running tasks from data loss
7. **Choose Reasoning Pattern**:
   - Simple: Direct response
   - Complex reasoning: Tree of Thought
   - Tool-intensive: ReWOO
   - Needs improvement: Reflexion
   - Long workflows: Plan-and-Execute
8. **Human-in-the-Loop**: Enable approval for sensitive operations
9. **Async Execution**: Use for long tasks to avoid blocking
10. **Sandbox Execution**: Always run AI-generated code in sandbox
11. **Defensive Prompts**: Enable injection protection and output validation
12. **Hierarchical Architecture**: Use Supervisor-Worker pattern for complex systems
13. **Multi-Agent Collaboration**: Choose appropriate mode (Debate/Consensus/Pipeline)
14. **Crews Teams**: Define clear role responsibilities
15. **Smart Memory Management**: Enable intelligent decay to prevent memory bloat
16. **Federation**: Use federation orchestrator for cross-organization scenarios
17. **Containerized Deployment**: Use K8s or cloud services for production
