# Tool Integration Guide

AgentFlow provides a complete tool system with registration, execution, ReAct loops, parallel execution, and rate limiting.

## Tool Registration

```go
import (
    "github.com/BaSui01/agentflow/llm"
    "github.com/BaSui01/agentflow/llm/tools"
)

registry := tools.NewDefaultRegistry(logger)

// Define tool function
searchFunc := func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Query string `json:"query"`
    }
    json.Unmarshal(args, &params)
    results := doSearch(params.Query)
    return json.Marshal(results)
}

// Register tool
registry.Register("search", searchFunc, tools.ToolMetadata{
    Schema: llm.ToolSchema{
        Name:        "search",
        Description: "Search the internet for information",
        Parameters: json.RawMessage(`{
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "Search keywords"}
            },
            "required": ["query"]
        }`),
    },
    Timeout: 30 * time.Second,
    RateLimit: &tools.RateLimitConfig{
        MaxCalls: 10,
        Window:   time.Minute,
    },
})
```

## Tool Executor

```go
executor := tools.NewDefaultExecutor(registry, logger)

// Execute single tool
result := executor.ExecuteOne(ctx, llm.ToolCall{
    ID:        "call_1",
    Name:      "search",
    Arguments: json.RawMessage(`{"query": "Go tutorials"}`),
})

// Execute multiple tools (parallel)
results := executor.Execute(ctx, toolCalls)
```

## ReAct Executor

Automatic LLM → Tool → LLM loop:

```go
reactExecutor := tools.NewReActExecutor(
    provider,
    executor,
    tools.ReActConfig{
        MaxIterations: 10,
        StopOnError:   false,
    },
    logger,
)

req := &llm.ChatRequest{
    Model: "gpt-4o",
    Messages: []llm.Message{
        {Role: llm.RoleUser, Content: "Search for Go 1.24 features and summarize"},
    },
    Tools: registry.List(),
}

response, steps, err := reactExecutor.Execute(ctx, req)

for _, step := range steps {
    fmt.Printf("Step %d: %s\n", step.StepNumber, step.Thought)
}
```

### Streaming ReAct

```go
eventCh, err := reactExecutor.ExecuteStream(ctx, req)

for event := range eventCh {
    switch event.Type {
    case "llm_chunk":
        fmt.Print(event.Chunk.Delta.Content)
    case "tools_start":
        fmt.Printf("Executing tools: %v\n", event.ToolCalls)
    case "tools_end":
        fmt.Println("Tools completed")
    case "completed":
        fmt.Println("Done")
    }
}
```

## Tool Fallback

```go
fallbackExecutor := tools.NewFallbackExecutor(executor, tools.FallbackConfig{
    Fallbacks: map[string][]string{
        "search": {"search_backup", "web_scrape"},
    },
    MaxRetries: 2,
})
```

## Common Tool Examples

### File Operations

```go
registry.Register("read_file", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        Path string `json:"path"`
    }
    json.Unmarshal(args, &params)
    content, err := os.ReadFile(params.Path)
    if err != nil {
        return nil, err
    }
    return json.Marshal(map[string]string{"content": string(content)})
}, metadata)
```

### HTTP Requests

```go
registry.Register("http_request", func(ctx context.Context, args json.RawMessage) (json.RawMessage, error) {
    var params struct {
        URL    string `json:"url"`
        Method string `json:"method"`
    }
    json.Unmarshal(args, &params)
    
    req, _ := http.NewRequestWithContext(ctx, params.Method, params.URL, nil)
    resp, err := http.DefaultClient.Do(req)
    // ...
}, metadata)
```

## OpenAPI Tool Generation

```go
import "github.com/BaSui01/agentflow/tools/openapi"

generator := openapi.NewGenerator(openapi.Config{
    BaseURL: "https://api.example.com",
})

tools, err := generator.GenerateFromSpec("./openapi.yaml")
for _, tool := range tools {
    registry.Register(tool.Name, tool.Func, tool.Metadata)
}
```

## Best Practices

1. Clear tool descriptions for LLM selection
2. Validate parameters in tool functions
3. Set appropriate timeouts
4. Use rate limiting for external APIs
5. Return structured error messages
6. Log tool calls for debugging

## Advanced Features

### Tool Result Structure

```go
type ToolResult struct {
    ToolCallID string          `json:"tool_call_id"`
    Name       string          `json:"name"`
    Result     json.RawMessage `json:"result"`
    Error      string          `json:"error,omitempty"`
    Duration   time.Duration   `json:"duration"`
}
```

### Tool Metadata

```go
type ToolMetadata struct {
    Schema      llm.ToolSchema
    Permission  string           // Required permission
    RateLimit   *RateLimitConfig
    Timeout     time.Duration    // Default 30s
    Description string
}
```

### Dynamic Tool Registration

```go
// Register at runtime
registry.Register("dynamic_tool", dynamicFunc, metadata)

// Unregister at runtime
registry.Unregister("dynamic_tool")
```

### Permission Control

```go
registry.Register("admin_tool", adminFunc, tools.ToolMetadata{
    Schema:     schema,
    Permission: "admin",
})

// Check permission before execution
func (e *SecureExecutor) ExecuteOne(ctx context.Context, call llm.ToolCall) ToolResult {
    _, meta, _ := e.registry.Get(call.Name)
    if meta.Permission != "" && !user.HasPermission(meta.Permission) {
        return ToolResult{Error: "permission denied"}
    }
    return e.executor.ExecuteOne(ctx, call)
}
```
