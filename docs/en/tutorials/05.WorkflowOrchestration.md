# Workflow Orchestration

AgentFlow provides multiple workflow patterns including chain, parallel, DAG, conditional routing, loops, subgraphs, and checkpoints.

## Chain Workflow

Sequential step execution:

```go
import "github.com/BaSui01/agentflow/workflow"

step1 := workflow.NewFuncStep("extract", extractFunc)
step2 := workflow.NewFuncStep("analyze", analyzeFunc)
step3 := workflow.NewFuncStep("generate", generateFunc)

chain := workflow.NewChainWorkflow("Text Analysis", "Extract → Analyze → Generate", step1, step2, step3)
result, err := chain.Execute(ctx, input)
```

## Parallel Workflow

Concurrent task execution:

```go
parallel := workflow.NewParallelWorkflow("Parallel Processing", "Run multiple analyses")
parallel.AddBranch("sentiment", sentimentStep)
parallel.AddBranch("ner", nerStep)
parallel.AddBranch("keywords", keywordStep)

results, err := parallel.Execute(ctx, input)
// results is map[string]interface{}
```

## DAG Workflow

Directed Acyclic Graph with complex dependencies:

### Basic DAG

```go
dag := workflow.NewDAGBuilder("Complex Flow").
    AddNode("input", workflow.NodeTypeAction, inputStep).
    AddNode("process", workflow.NodeTypeAction, processStep).
    AddNode("output", workflow.NodeTypeAction, outputStep).
    AddEdge("input", "process").
    AddEdge("process", "output").
    Build()

executor := workflow.NewDAGExecutor(nil, logger)
result, err := executor.Execute(ctx, dag, input)
```

### Conditional Nodes

```go
dag := workflow.NewDAGBuilder("Conditional Flow").
    AddNode("check", workflow.NodeTypeCondition, nil).
    AddNode("pathA", workflow.NodeTypeAction, pathAStep).
    AddNode("pathB", workflow.NodeTypeAction, pathBStep).
    SetCondition("check", func(ctx context.Context, input interface{}) (bool, error) {
        return input.(Data).Score > 0.5, nil
    }).
    SetNodeMetadata("check", map[string]interface{}{
        "on_true":  []string{"pathA"},
        "on_false": []string{"pathB"},
    }).
    Build()
```

### Loop Nodes

```go
// While loop
dag := workflow.NewDAGBuilder("Iterative").
    AddNode("loop", workflow.NodeTypeLoop, nil).
    SetLoopConfig("loop", &workflow.LoopConfig{
        Type:          workflow.LoopTypeWhile,
        MaxIterations: 10,
        Condition: func(ctx context.Context, input interface{}) (bool, error) {
            return input.(Result).Quality < 0.9, nil
        },
    }).
    Build()

// ForEach loop
dag := workflow.NewDAGBuilder("Batch").
    AddNode("loop", workflow.NodeTypeLoop, nil).
    SetLoopConfig("loop", &workflow.LoopConfig{
        Type: workflow.LoopTypeForEach,
        Iterator: func(ctx context.Context, input interface{}) ([]interface{}, error) {
            return input.([]Item), nil
        },
    }).
    Build()
```

### Parallel Nodes

```go
dag := workflow.NewDAGBuilder("Parallel").
    AddNode("parallel", workflow.NodeTypeParallel, nil).
    AddNode("taskA", workflow.NodeTypeAction, taskAStep).
    AddNode("taskB", workflow.NodeTypeAction, taskBStep).
    AddEdge("parallel", "taskA").
    AddEdge("parallel", "taskB").
    Build()
```

### Subgraph Nodes

```go
subGraph := workflow.NewDAGBuilder("Sub Flow").
    AddNode("sub1", workflow.NodeTypeAction, sub1Step).
    Build()

dag := workflow.NewDAGBuilder("Main Flow").
    AddNode("sub", workflow.NodeTypeSubGraph, nil).
    SetSubGraph("sub", subGraph).
    Build()
```

## Error Handling

```go
dag := workflow.NewDAGBuilder("Fault Tolerant").
    AddNode("risky", workflow.NodeTypeAction, riskyStep).
    SetErrorConfig("risky", &workflow.ErrorConfig{
        Strategy:      workflow.ErrorStrategyRetry,
        MaxRetries:    3,
        RetryDelayMs:  1000,
        FallbackValue: defaultResult,
    }).
    Build()
```

### Error Strategies

| Strategy | Description |
|----------|-------------|
| `ErrorStrategyFailFast` | Fail immediately (default) |
| `ErrorStrategySkip` | Skip failed node, use fallback |
| `ErrorStrategyRetry` | Retry specified times |

## Checkpoints

```go
checkpointMgr := workflow.NewCheckpointManager(config)

dag := workflow.NewDAGBuilder("Long Flow").
    AddNode("step1", workflow.NodeTypeAction, step1).
    AddNode("checkpoint", workflow.NodeTypeCheckpoint, nil).
    AddNode("step2", workflow.NodeTypeAction, step2).
    AddEdge("step1", "checkpoint").
    AddEdge("checkpoint", "step2").
    Build()

executor := workflow.NewDAGExecutor(checkpointMgr, logger)
result, err := executor.Execute(ctx, dag, input)

// Resume from checkpoint on failure
checkpoint, _ := checkpointMgr.GetLatest(ctx, executionID)
result, err = executor.ResumeFromCheckpoint(ctx, dag, checkpoint)
```

## Execution History

```go
history := executor.GetHistory()
fmt.Printf("Execution ID: %s\n", history.ExecutionID)
fmt.Printf("Status: %s\n", history.Status)

for _, node := range history.Nodes {
    fmt.Printf("Node %s: %s, Duration: %v\n", node.NodeID, node.Status, node.Duration)
}
```

## DAG Serialization

```go
jsonData, err := workflow.SerializeDAG(dag)
loadedDAG, err := workflow.DeserializeDAG(jsonData)
```

## Best Practices

1. Single responsibility per node
2. Set timeouts for long-running nodes
3. Use checkpoints for long workflows
4. Configure retry and fallback for critical nodes
5. Record execution history for debugging
6. Use parallel nodes for independent tasks

## Advanced Features

### DAG Builder Fluent API

```go
workflow, err := workflow.NewDAGBuilder("Complex Flow").
    WithDescription("Multi-step data processing").
    AddNode("input", workflow.NodeTypeAction).
        WithStep(inputStep).
        Done().
    AddNode("validate", workflow.NodeTypeCondition).
        WithCondition(validateFunc).
        WithOnTrue("process").
        WithOnFalse("reject").
        Done().
    AddNode("process", workflow.NodeTypeAction).
        WithStep(processStep).
        WithErrorConfig(workflow.ErrorConfig{
            Strategy:   workflow.ErrorStrategyRetry,
            MaxRetries: 3,
        }).
        Done().
    AddEdge("input", "validate").
    SetEntry("input").
    Build()
```

### Node Types

| Type | Description |
|------|-------------|
| `NodeTypeAction` | Execute a step |
| `NodeTypeCondition` | Conditional branching |
| `NodeTypeLoop` | Loop iteration |
| `NodeTypeParallel` | Parallel execution |
| `NodeTypeSubGraph` | Nested subgraph |
| `NodeTypeCheckpoint` | Checkpoint |

### Loop Types

| Type | Description |
|------|-------------|
| `LoopTypeWhile` | Condition-based loop |
| `LoopTypeFor` | Fixed iteration count |
| `LoopTypeForEach` | Iterate over collection |

### DAG Validation

Builder automatically validates:
- Node existence
- Entry node configuration
- Edge references
- Cycle detection
- Orphaned node detection
- Node configuration (Action needs Step, Condition needs function, etc.)

### Loop Depth Protection

Built-in protection against infinite loops:

```go
const maxLoopDepth = 1000
// Returns error when exceeded
```
