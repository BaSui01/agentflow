package agent

import (
	"context"
	"testing"

	"github.com/BaSui01/agentflow/llm"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.uber.org/zap"
)

// TestToolProvider_NilFallback 不设置 toolProvider 时，所有调用走 provider（向后兼容）
func TestToolProvider_NilFallback(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	bus := new(MockEventBus)

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, bus, logger)

	// toolProvider 应该为 nil
	assert.Nil(t, agent.ToolProvider(), "toolProvider 未设置时应为 nil")
	assert.Equal(t, mainProvider, agent.Provider(), "主 provider 应正确返回")

	// 无工具时直接走 provider.Completion
	mockResp := &llm.ChatResponse{
		ID:       "resp-1",
		Provider: "main",
		Model:    "claude-sonnet-4-6",
		Choices: []llm.ChatChoice{{
			Index:        0,
			FinishReason: "stop",
			Message:      llm.Message{Role: llm.RoleAssistant, Content: "Hello from main!"},
		}},
	}
	mainProvider.On("Completion", mock.Anything, mock.Anything).Return(mockResp, nil).Once()

	resp, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "Hi"},
	})

	assert.NoError(t, err)
	assert.Equal(t, "Hello from main!", resp.Choices[0].Message.Content)
	mainProvider.AssertExpectations(t)
}

// TestToolProvider_SetAndGet 测试 SetToolProvider 和 ToolProvider 访问器
func TestToolProvider_SetAndGet(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolProvider := new(MockProvider)

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, nil, logger)

	// 初始为 nil
	assert.Nil(t, agent.ToolProvider())

	// 设置 toolProvider
	agent.SetToolProvider(toolProvider)
	assert.Equal(t, toolProvider, agent.ToolProvider(), "SetToolProvider 后应能正确获取")

	// 清除 toolProvider
	agent.SetToolProvider(nil)
	assert.Nil(t, agent.ToolProvider(), "设置为 nil 后应恢复")
}

// TestToolProvider_NoToolsUsesMainProvider 无工具时，即使设置了 toolProvider，也走主 provider
func TestToolProvider_NoToolsUsesMainProvider(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolProvider := new(MockProvider)

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		// 注意：没有配置 Tools
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, nil, logger)
	agent.SetToolProvider(toolProvider)

	mockResp := &llm.ChatResponse{
		ID:       "resp-main",
		Provider: "main-provider",
		Model:    "claude-sonnet-4-6",
		Choices: []llm.ChatChoice{{
			Index:        0,
			FinishReason: "stop",
			Message:      llm.Message{Role: llm.RoleAssistant, Content: "Generated by main"},
		}},
	}

	// 只有 mainProvider 被调用，toolProvider 不应被调用
	mainProvider.On("Completion", mock.Anything, mock.Anything).Return(mockResp, nil).Once()

	resp, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "Write a poem"},
	})

	assert.NoError(t, err)
	assert.Equal(t, "Generated by main", resp.Choices[0].Message.Content)
	assert.Equal(t, "main-provider", resp.Provider)
	mainProvider.AssertExpectations(t)
	toolProvider.AssertNotCalled(t, "Completion", mock.Anything, mock.Anything)
	toolProvider.AssertNotCalled(t, "Stream", mock.Anything, mock.Anything)
}

// TestToolProvider_Builder 测试 Builder 的 WithToolProvider 链式调用
func TestToolProvider_Builder(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolProvider := new(MockProvider)

	config := Config{
		ID:    "test-builder-dual",
		Name:  "Builder Dual Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent, err := NewAgentBuilder(config).
		WithProvider(mainProvider).
		WithToolProvider(toolProvider).
		WithLogger(logger).
		Build()

	assert.NoError(t, err)
	assert.NotNil(t, agent)
	assert.Equal(t, mainProvider, agent.Provider(), "主 provider 应正确设置")
	assert.Equal(t, toolProvider, agent.ToolProvider(), "toolProvider 应通过 Builder 正确注入")
}

// TestToolProvider_FunctionCallingValidation 测试 toolProvider 不支持 function calling 时报错
func TestToolProvider_FunctionCallingValidation(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolProvider := new(MockProvider)
	toolMgr := new(MockToolManager)

	config := Config{
		ID:    "test-dual-fc",
		Name:  "Dual FC Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	agent.SetToolProvider(toolProvider)

	// toolProvider 不支持 function calling → 应报错
	toolProvider.On("SupportsNativeFunctionCalling").Return(false)
	toolProvider.On("Name").Return("cheap-model")
	toolMgr.On("GetAllowedTools", "test-dual-fc").Return([]llm.ToolSchema{
		{Name: "search", Description: "search tool"},
	})

	_, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "cheap-model")
}

// TestToolProvider_FunctionCallingValidation_StreamCompletion 测试 StreamCompletion 的 FC 校验
func TestToolProvider_FunctionCallingValidation_StreamCompletion(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolProvider := new(MockProvider)
	toolMgr := new(MockToolManager)

	config := Config{
		ID:    "test-dual-fc-stream",
		Name:  "Dual FC Stream Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	agent.SetToolProvider(toolProvider)

	// toolProvider 不支持 function calling → StreamCompletion 也应报错
	toolProvider.On("SupportsNativeFunctionCalling").Return(false)
	toolProvider.On("Name").Return("cheap-model")
	toolMgr.On("GetAllowedTools", "test-dual-fc-stream").Return([]llm.ToolSchema{
		{Name: "search", Description: "search tool"},
	})

	_, err := agent.StreamCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "cheap-model")
}

// TestToolProvider_FunctionCallingValidation_NilToolProvider toolProvider 为 nil 时退化校验 provider
func TestToolProvider_FunctionCallingValidation_NilToolProvider(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)
	toolMgr := new(MockToolManager)

	config := Config{
		ID:    "test-fc-nil-tp",
		Name:  "FC Nil ToolProvider Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	// 不设置 toolProvider → 退化校验 mainProvider

	mainProvider.On("SupportsNativeFunctionCalling").Return(false)
	mainProvider.On("Name").Return("main-no-fc")
	toolMgr.On("GetAllowedTools", "test-fc-nil-tp").Return([]llm.ToolSchema{
		{Name: "search", Description: "search tool"},
	})

	_, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "main-no-fc")
}

// TestToolProvider_BuilderWithoutToolProvider Builder 不设置 toolProvider 时向后兼容
func TestToolProvider_BuilderWithoutToolProvider(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := new(MockProvider)

	config := Config{
		ID:    "test-builder-single",
		Name:  "Builder Single Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent, err := NewAgentBuilder(config).
		WithProvider(mainProvider).
		WithLogger(logger).
		Build()

	assert.NoError(t, err)
	assert.NotNil(t, agent)
	assert.Equal(t, mainProvider, agent.Provider())
	assert.Nil(t, agent.ToolProvider(), "不设置 toolProvider 时应为 nil（向后兼容）")
}
