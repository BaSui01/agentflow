package agent

import (
	"context"
	"sync/atomic"
	"testing"

	"github.com/BaSui01/agentflow/llm"
	"github.com/stretchr/testify/assert"
	"go.uber.org/zap"
)

// TestToolProvider_NilFallback 不设置 toolProvider 时，所有调用走 provider（向后兼容）
func TestToolProvider_NilFallback(t *testing.T) {
	logger := zap.NewNop()

	mockResp := &llm.ChatResponse{
		ID:       "resp-1",
		Provider: "main",
		Model:    "claude-sonnet-4-6",
		Choices: []llm.ChatChoice{{
			Index:        0,
			FinishReason: "stop",
			Message:      llm.Message{Role: llm.RoleAssistant, Content: "Hello from main!"},
		}},
	}

	var completionCalled atomic.Int32
	mainProvider := &testProvider{
		name: "main",
		completionFn: func(ctx context.Context, req *llm.ChatRequest) (*llm.ChatResponse, error) {
			completionCalled.Add(1)
			return mockResp, nil
		},
	}
	bus := &testEventBus{}

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, bus, logger)

	// toolProvider 应该为 nil
	assert.Nil(t, agent.ToolProvider(), "toolProvider 未设置时应为 nil")
	assert.Equal(t, mainProvider, agent.Provider(), "主 provider 应正确返回")

	resp, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "Hi"},
	})

	assert.NoError(t, err)
	assert.Equal(t, "Hello from main!", resp.Choices[0].Message.Content)
	assert.Equal(t, int32(1), completionCalled.Load())
}

// TestToolProvider_SetAndGet 测试 SetToolProvider 和 ToolProvider 访问器
func TestToolProvider_SetAndGet(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main"}
	toolProvider := &testProvider{name: "tool"}

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, nil, logger)

	// 初始为 nil
	assert.Nil(t, agent.ToolProvider())

	// 设置 toolProvider
	agent.SetToolProvider(toolProvider)
	assert.Equal(t, toolProvider, agent.ToolProvider(), "SetToolProvider 后应能正确获取")

	// 清除 toolProvider
	agent.SetToolProvider(nil)
	assert.Nil(t, agent.ToolProvider(), "设置为 nil 后应恢复")
}

// TestToolProvider_NoToolsUsesMainProvider 无工具时，即使设置了 toolProvider，也走主 provider
func TestToolProvider_NoToolsUsesMainProvider(t *testing.T) {
	logger := zap.NewNop()

	mockResp := &llm.ChatResponse{
		ID:       "resp-main",
		Provider: "main-provider",
		Model:    "claude-sonnet-4-6",
		Choices: []llm.ChatChoice{{
			Index:        0,
			FinishReason: "stop",
			Message:      llm.Message{Role: llm.RoleAssistant, Content: "Generated by main"},
		}},
	}

	var mainCalled, toolCalled atomic.Int32
	mainProvider := &testProvider{
		name: "main-provider",
		completionFn: func(ctx context.Context, req *llm.ChatRequest) (*llm.ChatResponse, error) {
			mainCalled.Add(1)
			return mockResp, nil
		},
	}
	toolProvider := &testProvider{
		name: "tool-provider",
		completionFn: func(ctx context.Context, req *llm.ChatRequest) (*llm.ChatResponse, error) {
			toolCalled.Add(1)
			return nil, nil
		},
	}

	config := Config{
		ID:    "test-dual",
		Name:  "Dual Model Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		// 注意：没有配置 Tools
	}

	agent := NewBaseAgent(config, mainProvider, nil, nil, nil, logger)
	agent.SetToolProvider(toolProvider)

	resp, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "Write a poem"},
	})

	assert.NoError(t, err)
	assert.Equal(t, "Generated by main", resp.Choices[0].Message.Content)
	assert.Equal(t, "main-provider", resp.Provider)
	assert.Equal(t, int32(1), mainCalled.Load(), "mainProvider should be called once")
	assert.Equal(t, int32(0), toolCalled.Load(), "toolProvider should not be called")
}

// TestToolProvider_Builder 测试 Builder 的 WithToolProvider 链式调用
func TestToolProvider_Builder(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main"}
	toolProvider := &testProvider{name: "tool"}

	config := Config{
		ID:    "test-builder-dual",
		Name:  "Builder Dual Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent, err := NewAgentBuilder(config).
		WithProvider(mainProvider).
		WithToolProvider(toolProvider).
		WithLogger(logger).
		Build()

	assert.NoError(t, err)
	assert.NotNil(t, agent)
	assert.Equal(t, mainProvider, agent.Provider(), "主 provider 应正确设置")
	assert.Equal(t, toolProvider, agent.ToolProvider(), "toolProvider 应通过 Builder 正确注入")
}

// TestToolProvider_FunctionCallingValidation 测试 toolProvider 不支持 function calling 时报错
func TestToolProvider_FunctionCallingValidation(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main"}
	toolProvider := &testProvider{name: "cheap-model", supportsNative: false}
	toolMgr := &testToolManager{
		getAllowedToolsFn: func(agentID string) []llm.ToolSchema {
			return []llm.ToolSchema{{Name: "search", Description: "search tool"}}
		},
	}

	config := Config{
		ID:    "test-dual-fc",
		Name:  "Dual FC Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	agent.SetToolProvider(toolProvider)

	_, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "cheap-model")
}

// TestToolProvider_FunctionCallingValidation_StreamCompletion 测试 StreamCompletion 的 FC 校验
func TestToolProvider_FunctionCallingValidation_StreamCompletion(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main"}
	toolProvider := &testProvider{name: "cheap-model", supportsNative: false}
	toolMgr := &testToolManager{
		getAllowedToolsFn: func(agentID string) []llm.ToolSchema {
			return []llm.ToolSchema{{Name: "search", Description: "search tool"}}
		},
	}

	config := Config{
		ID:    "test-dual-fc-stream",
		Name:  "Dual FC Stream Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	agent.SetToolProvider(toolProvider)

	_, err := agent.StreamCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "cheap-model")
}

// TestToolProvider_FunctionCallingValidation_NilToolProvider toolProvider 为 nil 时退化校验 provider
func TestToolProvider_FunctionCallingValidation_NilToolProvider(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main-no-fc", supportsNative: false}
	toolMgr := &testToolManager{
		getAllowedToolsFn: func(agentID string) []llm.ToolSchema {
			return []llm.ToolSchema{{Name: "search", Description: "search tool"}}
		},
	}

	config := Config{
		ID:    "test-fc-nil-tp",
		Name:  "FC Nil ToolProvider Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
		Tools: []string{"search"},
	}

	agent := NewBaseAgent(config, mainProvider, nil, toolMgr, nil, logger)
	// 不设置 toolProvider → 退化校验 mainProvider

	_, err := agent.ChatCompletion(context.Background(), []llm.Message{
		{Role: llm.RoleUser, Content: "search something"},
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "does not support native function calling")
	assert.Contains(t, err.Error(), "main-no-fc")
}

// TestToolProvider_BuilderWithoutToolProvider Builder 不设置 toolProvider 时向后兼容
func TestToolProvider_BuilderWithoutToolProvider(t *testing.T) {
	logger := zap.NewNop()
	mainProvider := &testProvider{name: "main"}

	config := Config{
		ID:    "test-builder-single",
		Name:  "Builder Single Agent",
		Type:  TypeGeneric,
		Model: "claude-sonnet-4-6",
	}

	agent, err := NewAgentBuilder(config).
		WithProvider(mainProvider).
		WithLogger(logger).
		Build()

	assert.NoError(t, err)
	assert.NotNil(t, agent)
	assert.Equal(t, mainProvider, agent.Provider())
	assert.Nil(t, agent.ToolProvider(), "不设置 toolProvider 时应为 nil（向后兼容）")
}
