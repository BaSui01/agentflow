// 版权所有 2024 AgentFlow Authors. 版权所有。
// 此源代码的使用由 MIT 许可规范,该许可可以是
// 在LICENSE文件中找到。

/*
包代理为AgentFlow提供了核心代理框架.

# 概览

代理包执行一个灵活、可扩展的代理架构,支持
各种AI代理模式,包括ReAct,Chain-of-Thought,以及自定义工作流程.
它提供了一个统一的接口 用于建立智能代理 能够解释,
计划,并使用大语言模型执行任务。

建筑

代理框架遵循分层结构:

	┌─────────────────────────────────────────────────────────────┐
	代理接口
	│  （标识、名称、类型、状态、初始化、清理、规划、执行）      │
	├─────────────────────────────────────────────────────────────┤
	基地探员
	│  （通用能力、生命周期管理、钩子机制）                        │
	├─────────────────────────────────────────────────────────────┤
	│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
	{\fn华文楷体\fs16\1cHE0E0E0}记忆 {\fn华文楷体\fs16\1cHE0E0E0}工具 {\fn华文楷体\fs16\1cHE0E0E0}守护者
	## # # # # 管理者 # # # # # # # 管理者 # # # # # # # # # # 管理者 # # # # # # # 管理者 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
	├─────────────────────────────────────────────────────────────┤
	LLM提供商
	└─────────────────────────────────────────────────────────────┘

# 核心组件

代理接口:定义所有代理执行的合同.

	类型代理接口{
	    ID()字符串
	    名称( ) 字符串
	    类型 () 代理类型
	    国家( )
	    Init( ctx 上下文 ). 背景)错误
	    倒地( ctx 上下文) 。 背景)错误
	    计划( ctx 上下文 ). 背景, 输入 * 输入 (* PlanResult, 错误)
	    执行( ctx 上下文) 。 背景,输入 *输入 (*输出,出错)
	    央视( ctx 上下文). 背景, 反馈 * Feedback) 错误
	}

BaseAgent:为所有代理类型提供共同功能,包括:
  - 生命周期管理(Init,Dear-down)
  - 国家机器(运行)
  - Hook系统(执行前,执行后,执行后,执行后)
  - 检查站/复原支助

内存管理器: 跨多层管理代理内存 :
  - 工作记忆:短期上下文存储
  - 记忆:事件经验
  - 语义记忆:事实知识
  - 程序记忆:如何了解

ToolManager:处理工具的注册,选择,和执行.

使用量

使用构建器模式创建基本代理 :

	代理,错误:=代理. NewAgentBuilder(代理). 配置{
	    姓名:"我的代理人",
	    类型:特工。 类型ReAct,
	    最大强度: 10,
	}).
	    与 Provider(llm Provider) 连接.
	    带有 Memory( 记忆管理器) 。
	    带有 Tools( 工具管理器) 。
	    构建( C)

	如果错误 ! = 无 {
	    记录。 致命( err)
	}

	// 执行任务
	输出,错误:=代理。 执行( ctx, & agent) 。 输入{
	    问道:"北京天气如何?
	})

# 代理类型

框架支持多种代理类型:

  - TypeReAct:理由和行为模式
  - TypeCoT:思维链推理
  - TypePlanAndExecute:规划然后执行
  - 类型参考:自我反射和改进
  - TypeCustom:用户定义的代理逻辑

# 国家机器

特工跟踪一个定义明确的状态机器:

	闲 —— 运行 —— 已完成
	         ↓
	       失败

国家过渡得到验证,以确保正确的代理行为。

# 检查

该框架支持检查长期任务:

	// 启用检查
	代理。 允许检查( 检查点管理)

	// 从检查站收回
	代理。 从检查点( ctx, 检查点ID) 恢复

# 处理错误

软件包用错误代码定义结构错误 :

	var (英语:
	    ErrProvider NotSet = NewError(ErrCodeProvider NotSet,"未配置 LLM 提供者")
	    ErrAgent NotReady = NewError(ErrCodeNoReady,"代理未就绪状态")
	    ErrAgentBusy = NewError(ErrCodeBusy,"代理正忙于执行另一个任务").
	)

线索安全

所有代理实施都设计为线性安全. BaseAgent 用途 :
适当的同步原始物来保护共享状态.

广度

该框架旨在扩大:
  - 通过代理注册的定制代理类型
  - 通过验证器接口自定义验证器
  - 通过内存Store接口自定义内存存储器
  - 通过工具界面定制工具

附加功能见子包 :
  - 代理/护栏:输入/输出验证和安全
  - 代理/记忆:内存管理系统
  - 代理/评价:代理评价和A/B测试
  - 代理/结构化:结构化输出剖析
  - 代理/议定书/a2a:代理与代理通信
*/
package agent
