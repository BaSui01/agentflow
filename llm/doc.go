// 版权所有 2024 AgentFlow Authors. 版权所有。
// 此源代码的使用由 MIT 许可规范,该许可可以是
// 在LICENSE文件中找到。

/*
package llm提供统一的LLM提供者抽象和路由.

# 概览

llm 软件包提供了一个用于与多重交互的统一接口
大语言模型提供者. 它摘取了提供商的具体细节
并提供了路由,缓存,重试逻辑,可观察等特征.

建筑

	┌─────────────────────────────────────────────────────────────┐
	应用程序层
	├─────────────────────────────────────────────────────────────┤
	++ 路由器/ 负载平衡器 ++
	++(基于模型的路由、故障、负载平衡)+++
	├─────────────────────────────────────────────────────────────┤
	│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
	{\fn黑体\fs22\bord1\shad0\3aHBE\4aH00\fscx67\fscy66\2cHFFFFFF\3cH808080}再试一次 {\fn黑体\fs22\bord1\shad0\3aHBE\4aH00\fscx67\fscy66\2cHFFFFFF\3cH808080}可观察性 {\fn黑体\fs22\bord1\shad0\3aHBE\4aH00\fscx67\fscy66\2cHFFFFFF\3cH808080}我
	========================================================================================================================================================================================== (=============== (======== (=== (===== (===== (=========== ( (======= (======
	│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
	├─────────────────────────────────────────────────────────────┤
	提供方接口
	├──────────┬──────────┬──────────┬──────────┬────────────────┤
	{\fn黑体\fs22\bord1\shad0\3aHBE\4aH00\fscx67\fscy66\2cHFFFFFF\3cH808080}其他的...
	└──────────┴──────────┴──────────┴──────────┴────────────────┘

# 提供者接口

核心提供者接口为所有LLM提供者定义合同:

	类型提供者接口 {
	    补全( ctx 上下文 ). 背景, req *Chat request (*ChatResponse, 错误)
	    Stream( ctx) 上下文 。 上下文, req *Chat request ( <-chan StreamChunk, 错误)
	    健康检查( ctx) 上下文 。 (*健康状况,错误)
	    名称( ) 字符串
	    支持 NativeFunctionCalling () 布尔
	}

# 支持供应商

包支持框外的 13+ LLM 提供者 :

  - OpenAI(GPT-4,GPT-4o,GPT-3.5-涡轮)
  - Anthropic(克洛德3 Opus,索内特,海库)
  - Google(双子星双子星)
  - 深搜索 (深搜索聊天,深搜索编码)
  - 阿里巴巴 (克文-图尔博,克文-普卢斯,克文-马克斯)
  - 十美分(湖南)
  - 月光拍摄(基米)
  - 日普(GLM-4)
  - 字节(杜波)
  - 贝都语(爱沙尼亚)
  - 迷你麦克斯
  - 迷雾
  - 梅塔 (拉玛语)
  - XAI (希腊语)

使用量

单一供应商的基本使用:

	提供者, 错误 : = openai. New Provider( & openai). 配置{
	    爱比克:"你的爱比克",
	    型号:"gpt-4o",
	})
	如果错误 ! = 无 {
	    记录。 致命( err)
	}

	resp, 错误 := 提供者。 补全( ctx, &llm.). 聊天请求{
	    型号:"gpt-4o",
	    消息:[将. 信件{
	        {Role:llm.RoleUser,内容:"Hello!"},
	    },
	})

使用路由器进行多提供者设置 :

	路由器: = llm. NewRouter( )
	    与 Provider ("openai", "openai") 相接,
	    与Provider("人类","人类"),
	    与Fallback("人类"),
	)

	// 路由器根据模型自动选择提供者
	resp,错误:=路由器. 补全( ctx, &llm.). 聊天请求{
	    型号:"Claude-3-opus",//去往Anthropic的路线
	})

# 流淌着

所有提供者支持流化响应:

	流,错误:=提供者。 Stream( ctx, &llm.) (中文(简体) ). 聊天请求{
	    型号:"gpt-4o",
	    消息:消息,
	})
	如果错误 ! = 无 {
	    记录。 致命( err)
	}

	块 := 范围流 {
	    如果块。 错误 != 0 {
	        log.Printf(“错误:%v”),块。 错误)
	        换行
	    }
	    fmt.Print(圆). 内容)
	}

缓冲

该包提供多级缓存:

	缓存 := 缓存. New MultilevelCache( redisclient, &cache). 缓存Config{
	    本地MaxSize: 1000, (英语).
	    本地TTL: 5 *时间. 分钟,
	    (原始内容存档于2017-09-26). RedistL: 1 * time. 小时
	    启用本地端: 真实,
	    启用Redis: 真实,
	})

# 重试和复原力

内置重试, 以指数倒置 :

	具有弹性的提供方:=llm. NewResilient 提供方(提供方, &llm.ResienceConfig{
	    马克思瑞斯: 3,
	    (原始内容存档于2018-10-05). IntroductionBackoff: 100 * time. 毫秒时
	    麦克斯巴克夫:10*时间. 第二,我们...
	    电路分离器: 真实,
	})

# 观察

该套件与OpenTeleometry集成,用于测量和追踪:

	提供者:=可观察性。 WrapProvider( 基础提供, 可观察性) 。 配置{
	    启用度量衡: 真,
	    启用追踪: 真,
	    服务名:"我的服务",
	})

工具召唤

支持本地函数调用 :

	resp, 错误 := 提供者。 补全( ctx, &llm.). 聊天请求{
	    型号:"gpt-4o",
	    消息:消息,
	    工具:[llm. 工具计划{
	        {
	            名称:"Get weather",
	            描述:"获取当前天气作为位置",
	            参数:气象卫星系统
	        },
	    },
	})

# 处理错误

软件包定义了结构化错误代码 :

	康斯特( Const) (
	    无效请求错误Code = "无效请求"
	    错误校正错误Code="校正错误"
	    ErrRateLimit 错误代码 = "rate limit"
	    ErrContext TooLong 错误代码 = “ Context  too  long ”
	    ErrService 无法使用错误代码 = "Service  无法使用"
	)

使用 IsRetry 来检查是否可以重试一个错误 :

	如果 llm. 是可重试的( err) {
	    // 执行重试逻辑
	}

# API 密钥管理

支持旋转的 API 密钥集合 :

	池:=llm.NewAPIKeyPool(db,提供ID,llm. StrategyRound Robin,日志) 互联网档案馆的存檔,存档日期2013-12-21.
	移动键( ctx)
	键,错误:= pool.SelectKey(ctx)

附加功能见子包 :
  - ltm/cache:用多种策略快速缓存
  - llm/中件:请求/响应中件
  - 标准/可观察性:计量、追踪和费用追踪
  - llm/重试:重试策略和后退
  - ltm/routter:多供应商路线
  - llm/工具:ReAct循环和工具执行
  - ltm/提供者/*:针对提供者的具体实施
*/
package llm
